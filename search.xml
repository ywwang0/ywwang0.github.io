<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分类分析因素关联性</title>
    <url>/2020/09/15/%E5%88%86%E7%B1%BB%E5%88%86%E6%9E%90%E5%9B%A0%E7%B4%A0%E5%85%B3%E8%81%94%E6%80%A7/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">文件用pandas读入命名为df</span></span><br><span class="line"><span class="string">colume是待分类的一列</span></span><br><span class="line"><span class="string">label是待分类的列表，如我想分析data.csv文件夹下，的ads_ele下的x和Mg不同情况下的时候吸附能与一些变量的关系</span></span><br><span class="line"><span class="string">y是想分析的因变量，如吸附能</span></span><br><span class="line"><span class="string">x是想分析的自变量</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify_scatter</span><span class="params">(filename,column,y_goal,x_goal,labels)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8.3</span>,<span class="number">6</span>)) </span><br><span class="line">    label_font = &#123;<span class="string">'family'</span>:<span class="string">'Arial'</span>,<span class="string">'weight'</span>:<span class="string">'normal'</span>,<span class="string">'size'</span>:<span class="number">26</span>&#125;</span><br><span class="line">    legend_font = &#123;<span class="string">'family'</span>:<span class="string">'Arial'</span>,<span class="string">'weight'</span>:<span class="string">'normal'</span>,<span class="string">'size'</span>:<span class="number">15</span>&#125;</span><br><span class="line">    plt.rcParams[<span class="string">'xtick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将x周的刻度线方向设置向内</span></span><br><span class="line">    plt.rcParams[<span class="string">'ytick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将y轴的刻度方向设置向内</span></span><br><span class="line">    plt.yticks(fontproperties = <span class="string">'Arial'</span>, size = <span class="number">24</span>)</span><br><span class="line">    plt.xticks(fontproperties = <span class="string">'Arial'</span>, size = <span class="number">20</span>)</span><br><span class="line">    plt.ylabel(y_goal,label_font)</span><br><span class="line">    plt.xlabel(x_goal,label_font)</span><br><span class="line">    minorticks_on()</span><br><span class="line">    tick_params(which=<span class="string">'major'</span>,width=<span class="number">2</span>,length=<span class="number">6</span>)</span><br><span class="line">    tick_params(which=<span class="string">'minor'</span>,width=<span class="number">2</span>,length=<span class="number">4</span>)</span><br><span class="line">    bwith = <span class="number">2</span></span><br><span class="line">    ax=plt.gca()</span><br><span class="line">    ax.spines[<span class="string">'bottom'</span>].set_linewidth(bwith)    </span><br><span class="line">    ax.spines[<span class="string">'top'</span>].set_linewidth(bwith)</span><br><span class="line">    ax.spines[<span class="string">'left'</span>].set_linewidth(bwith)  </span><br><span class="line">    ax.spines[<span class="string">'right'</span>].set_linewidth(bwith)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> labels:</span><br><span class="line">        df = pd.read_excel(filename)</span><br><span class="line">        df = df[df[column] == str(label)]</span><br><span class="line">        y = np.array(df[y_goal]).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">        x = np.array(df[x_goal]).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        linear = linear_model.LinearRegression()</span><br><span class="line">        linear.fit(x, y)</span><br><span class="line"></span><br><span class="line">        y_true = y</span><br><span class="line">        y_pred = linear.predict(x)</span><br><span class="line">        plt.scatter(x, y,label=label+<span class="string">':$R^2$='</span>+str(round(r2_score(y_true,y_pred),<span class="number">3</span>)),s=<span class="number">160</span>,edgecolor=<span class="string">'black'</span>,alpha=<span class="number">0.8</span>)</span><br><span class="line">        x_aixs = np.linspace(np.min(x)<span class="number">-0.1</span>*(np.max(x)-np.min(x)),<span class="number">1.1</span>*np.max(x)+<span class="number">0.3</span>*(np.max(x)-np.min(x)),<span class="number">10</span>, endpoint=<span class="literal">True</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">        plt.plot(x_aixs, linear.predict(x_aixs), ls=<span class="string">'dashed'</span>)</span><br><span class="line">        plt.legend(loc=<span class="string">'best'</span>,prop =&#123;<span class="string">'family'</span>:<span class="string">'Arial'</span>,<span class="string">'weight'</span>:<span class="string">'normal'</span>,<span class="string">'size'</span>:<span class="number">14</span>&#125;,fancybox=<span class="literal">False</span>,edgecolor=<span class="string">'black'</span>)</span><br><span class="line">        plt.tight_layout()</span><br><span class="line">        plt.savefig(y_goal+<span class="string">'_'</span>+x_goal+<span class="string">'.pdf'</span>,dpi=<span class="number">300</span>)</span><br><span class="line">        print(label+<span class="string">'的R2:&#123;&#125;'</span>.format(r2_score(y_true,y_pred)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照哪一列分类</span></span><br><span class="line">column = <span class="string">'ads_ele'</span></span><br><span class="line"><span class="comment"># 将这一列的所有行分离出来</span></span><br><span class="line">labels = df[column].drop_duplicates(keep=<span class="string">'first'</span>, inplace=<span class="literal">False</span>).to_list()</span><br><span class="line"><span class="comment"># 目标变量和自变量</span></span><br><span class="line">y_analysis = <span class="string">'Ads_En'</span></span><br><span class="line">x_analysis = <span class="string">'Bader'</span></span><br><span class="line"></span><br><span class="line">classify_scatter(<span class="string">'raw.xlsx'</span>,column,y_analysis,x_analysis,labels)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>python画图配色</title>
    <url>/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/</url>
    <content><![CDATA[<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/1.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/2.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/3.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/4.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/5.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/6.png" alt></p>
<p><img src="/2020/09/11/python%E7%94%BB%E5%9B%BE%E9%85%8D%E8%89%B2/7.png" alt></p>
]]></content>
      <categories>
        <category>python数据分析与机器学习实战-唐宇迪</category>
      </categories>
  </entry>
  <entry>
    <title>双电层的建立</title>
    <url>/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<p>双电层建立的GCS模型</p>
<a id="more"></a>

<p>这篇文章想介绍电化学中一个很优雅的概念，并阐释这个概念如何通过建立模型而不断完善。<br>这个概念叫做：</p>
<blockquote>
<p><strong>双电层（electrical double layer）</strong></p>
</blockquote>
<p>假设，将一个金属片放进电解液中，那么会发生什么呢？或者更科学性的描述是：<strong>在电极与电解液的界面处，物质与电荷的分布状态是怎样的？</strong>下面选自百度百科的一段话：</p>
<blockquote>
<p>在双电层两侧之间,即电子导体相与离子导体之间的电位差就是所谓的电极电位。金属浸入电解质溶液中,金属表面由于晶格畸变能较高使表面金属离子易于和溶液中极性水分子作用而发生水化。如果金属离子的水化能高于金属表面晶格的键能,一些表面金属离子将脱离金属晶格进入溶液，形成水化离子。金属表面晶格的电子由于被水分子电子壳层中的同名电荷排斥，不能随水化反应转入溶液，因此就必然有相当数量的过剩电子在金属表面积累。<br>由于金属表面负电荷的吸引和溶液中正电荷的排斥,进入溶液的水化金属离子不能向溶液深处扩散,而只能滞留在金属表面附近，这就阻碍了表其他金属离子继续溶解。浴液中的部分水化金属离子也可能再沉积到金属表面。当溶解于沉积速度相等的时候,就可以在该处形成一种动态平衡的电荷分布。通常把金属与电解质溶液界面处形成的这种荷电的界面偶层称为双电层。<br>由于双电层的形成,界面处即双电层两侧之间变产生了电位差。</p>
</blockquote>
<h3 id="1-Helmholtz模型"><a href="#1-Helmholtz模型" class="headerlink" title="(1)Helmholtz模型"></a>(1)Helmholtz模型</h3><p>首先，亥姆赫兹（Helmholtz）试图探究这个问题，他建立了一个模型，我们简称其为H模型。<br>H模型的核心思想是：<code>相反的电荷等量分布于界面两侧</code>。这也是“double layer”的由来。</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/h.png" alt></p>
<p>进而，这个结构可以等效为一个平板电容器，并用如下公式描述单侧的电荷密度（σ）与两层电荷间的电势差（V）的关系，其中，d为正负电荷中心的距离。</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/formula.png" alt></p>
<p>至此，H模型成功地将将一个电化学的普遍场景抽象为基本公式。</p>
<p>然而，该模型存在一个明显缺陷：由上式可推论出，C是一个恒定值，然而实验观测中，C是一个变量，<strong>相对电位</strong>与<strong>电解液浓度</strong>等都会对其产生影响。</p>
<p>比如，汞电极在NaF电解液中，测得C值如下图所示</p>
<img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/exp.png" style="zoom:80%;">

<p>其中可以看到明显的两个趋势是:</p>
<p>（1）C相对于电位成V型的对称分布；</p>
<p>（2）电解液的浓度越高，C数值越大。</p>
<p>因此，一个良好双电层模型需要解释这两个现象。</p>
<h3 id="2-Gouy-Chapman模型"><a href="#2-Gouy-Chapman模型" class="headerlink" title="(2)Gouy-Chapman模型"></a>(2)Gouy-Chapman模型</h3><p>随后，Gouy和Chapman联手改进了这个模型，我们简称其为G-C模型。G-C模型的核心是引入了一个新的概念：<code>扩散层(diffuse layer)</code></p>
<p>让我们回到电极与电解液的界面处，电荷在电极这一侧是严格分布于其表面。然而，在电解液这一侧却不是这样：由于不同离子间的相互作用，使得很多电荷会扩散到远离界面的体相溶液中。</p>
<p>因此，G-C模型可由下图近似表示，</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/GC.png" alt></p>
<p>经过G-C模型的改进，原本电容公式中的d就变成了一个变量。</p>
<p>不难想象，当界面两侧电势差较大时，更多的离子会被压缩到靠近电极的位置；当电解液浓度高时，离子也可以在较小的空间上与电极达到电荷平衡。</p>
<p>经过G-C模型的改进，双电层预测NaF的水溶液作为电解液，其电容与电位及浓度关系如下，</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/gc_curve.png" alt></p>
<p>可见，经过G-C模型的改进，双电层理论对Cd变化有了很好的解释。</p>
<p>然而，G-C模型也是由弊端的：</p>
<p>（1）预测图中，在V型曲线的两端（既电位差极大处），C值趋近于无穷大。而实际测试中，在该处的C值趋向平缓；</p>
<p>（2）预测值远远高于实测值。</p>
<p>综上，我们可以说G-C模型揭示了“部分真理”，但与现实世界仍有较大偏差。</p>
<h3 id="（3）Gouy-Chapman-Stern模型"><a href="#（3）Gouy-Chapman-Stern模型" class="headerlink" title="（3）Gouy-Chapman-Stern模型"></a>（3）Gouy-Chapman-Stern模型</h3><p>G-C模型中，之所以会出现Cd无穷大的预测，是因为电荷被抽象为一个点，这也是物理学中常用的处理方法。</p>
<p>然而，当我们电势差很大时，这些抽象的“点电荷”会被无限压缩到接近电极表面的位置，因此正负电荷的距离d将趋紧于0，从而造成C接近无穷大。</p>
<p>据此，Stern在G-C模型的基础上，加入了一个新的条件：<code>离子是有尺寸的</code></p>
<p>进而，得到下图所示的G-C-S模型。</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/gcs.png" alt></p>
<p>G-C-S模型中，Stern将较为紧密的内层成为亥姆赫兹层（Helmholtz layer），该层产生的电容!C_H在固定体系中为恒定值，不受电势差的影响。外层仍为扩散层，产生电容C_D。</p>
<p>C_H与C_D为串联，共同组成双电层电容C_d，三者关系为：</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/gdc_formula.png" alt></p>
<p>由电学知识可知，C_d永远小于C_H与C_D中的较小值。在低电势差时，C_D值很小，C_d主要受其影响，而具有V型的特征。在高电势差时，C_D值很大，而对C_d值的贡献可以忽略不计，C_d趋近于$C_H$值。</p>
<p>至此，G-C-S模型妥善地解决了上文中涉及的问题。然而，事情并没有结束。</p>
<h3 id="4-后续"><a href="#4-后续" class="headerlink" title="(4)后续"></a>(4)后续</h3><p>G-C-S模型中仍然有很多未尽之处，比如：</p>
<p>（1）在实际情况中，电解液中的阴阳离子表面会被溶剂离子包围，电荷的载体是这种“溶剂化离子（solvated ions）”；</p>
<p>（2）在界面处会有吸附现象（adsorption）发生，如果吸附力大于静电力，那么即使是同种电荷也可以稳定处于界面处。</p>
<p>如果考虑这两点，那么，G-C-S模型的改进版将如下图所示，</p>
<p><img src="/2020/09/08/%E5%8F%8C%E7%94%B5%E5%B1%82%E7%9A%84%E5%BB%BA%E7%AB%8B/gcs_revised.png" alt></p>
]]></content>
      <categories>
        <category>腐蚀科学</category>
      </categories>
  </entry>
  <entry>
    <title>财务报销三步</title>
    <url>/2020/09/07/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E9%94%80%E4%B8%89%E6%AD%A5/</url>
    <content><![CDATA[<p>1.买东西并且所要发票</p>
<p>2.下载科研报销单并且按照要求填写，基金号可以先空着</p>
<p> <a href="财务报销三步/科研报销单.xls">科研报销单.xls</a> </p>
<p>3.去453科研办公室交给进门方向最左边里面的陆静洁老师</p>
]]></content>
  </entry>
  <entry>
    <title>LDA+U</title>
    <url>/2020/08/31/LDA-U/</url>
    <content><![CDATA[<p>加U体系</p>
<a id="more"></a>

<p>在平均场近似或者说是一般得LDA计算中，能带得自旋分裂是由一个称为Stoner 参数I来主导得，而且平均场近似中认为这个交换分裂能是小于带宽得，一般而言I得数值在LSDA中大概在1eV左右，这样即使对于某些氧化物如 NiO，FeO，MnO等即使能带发生交换分裂，整个体系依然是金属性得，试验观察到得这些氧化物实际上是绝缘体，主要原因在于在这些氧化物中d轨道得能级位置不是由I来决定得，而是Hubbard参数U决定，U也称为On－site Coulomb作用能，相当于把两个电子放在空间同一个位置需要得能量，U数值一般在10eV左右，如此大得分裂能足以将Fermi面附近连续分布得d能级分开，从而得到正确得基态性质，目前广泛采用得LDA＋U的算法就是针对某些定域轨道，如d或者f，这些轨道占据存在强烈的在位Coulomb排斥。正是U使得带隙分裂，而不是轨道极化参量I。<br>U计算目前仍然是一个研究热点，最近由人采用线性响应理论，同时结合轨道束缚的DFT计算自洽的求解了部分体系的U参数，在大部分情况下U数值要根据计算结果和试验参数的符合程度而定。<br>LDA＋U计算核心思路是：首先将研究体系的轨道分隔成两个子体系（subsystem），其中一部分是一般的DFT算法（如LSDA，GGA）等可以比较准确描述的体系，另外是定域在原子周围的轨道如d或者f轨道，这些轨道在标准的DFT计算下不能获得正确的能量与占据数之间的关系（如DFT总是认为分数占据是能量最小的，而不是整数占据）；对于d或者f轨道，能带模型采用Hubbard模型，而其他轨道仍然是按照Kohn－SHam方程求解；d以及f 轨道电子之间的关联能采用一个和轨道占据以及自旋相关的有效U表示；整体计算的时候需要将原来DFT计算过程中已经包含的部分关联能扣除，这部分一般叫 Double Counting part，并且用一个新的U来表示，最终的结果是在DFT计算的基础上新增加一个和d或者f轨道直接相关的分裂势的微扰项，这部分能量可以采用一般微扰理论计算。<br>在CASTEP最新的版本中增加的LDA＋U的计算，U参数的设置一般主要是针对过渡金属氧化物（Charge transfer type insulator），包含非满层f轨道的元素等，高温超导体强关联体系。在参数设置方面主要是需要注意d和f轨道，至于s以及p轨道一般不需要设置，当然由文献也报道p轨道的这种关联性。过渡金属氧化物的有效U如下：</p>
<table>
<thead>
<tr>
<th align="center">Species</th>
<th>U</th>
<th>J</th>
<th align="center">U-J（UEff）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NiO</td>
<td>8.0</td>
<td>0.95</td>
<td align="center">7.1</td>
</tr>
<tr>
<td align="center">CoO</td>
<td>7.8</td>
<td>0.92</td>
<td align="center">6.9</td>
</tr>
<tr>
<td align="center">FeO</td>
<td>6.8</td>
<td>0.89</td>
<td align="center">5.9</td>
</tr>
<tr>
<td align="center">MnO</td>
<td>6.9</td>
<td>0.86</td>
<td align="center">10.3</td>
</tr>
<tr>
<td align="center">VO</td>
<td>6.7</td>
<td>0.81</td>
<td align="center">5.9</td>
</tr>
<tr>
<td align="center">TiO</td>
<td>6.6</td>
<td>0.78</td>
<td align="center">5.8</td>
</tr>
</tbody></table>
<p>Reference: Band theory and Mott insulators: Hubbard U insteat of Stoner I, PRB Vol44 No 3 (1991);<br>3d轨道U和J计算如下所示：主要原理是改变d轨道的占据，在自旋极化的前提下计算不同自旋轨道能量的差值提取U和J，U微Coulomb排斥能，J是交换能，U在所有电子中都存在，不管自旋是否相同，J只存在于自旋相同的电子上。<br>下面给出过渡金属（不包括稀土元素）U和J参数的选取(uint in Ry,1Ry=13.6eV)：</p>
<p>3d series:<br>Elements    U         J<br>V         0.25       0.05<br>Cr         0.26       0.053<br>Mn         0.28       0.055<br>Fe         0.3         0.058<br>Co         0.31       0.059<br>Ni           0.31       0.06<br>4d series:<br>Elements    U           J<br>Nb           0.19       0.04<br>Mo           0.2         0.04<br>Tc           0.21       0.042<br>Ru           0.22       0.042<br>Rh           0.25       0.044<br>Pd           0.29       0.044<br>5d series:<br>Elements      U          J<br>Ta           0.19       0.039<br>W          0.20       0.038<br>Re           0.205        0.039<br>Os           0.2         0.039<br>Ir            0.21       0.038<br>Pt          0.215        0.038<br>对于其他过渡金属化合物U一般在5－10eV之间。如在PRB73，134418（2006）这个文献中作者在计算Co掺杂的ZnO时采用的U是6和 8eV。过渡金属的U数值和d电子排列以及价态有关系，因此上面给出的数值只是一个大概的估算数值，具体文献见Physical Review B Vol50,No23,1994.<br>LDA+U 算法主要原创作者是俄罗斯金属研究所的V.I. Anisimov，重要文献有：<br>Corrected atomic limit in the local density approximation and the electronic structure of d impurities in Rb, Phys.Rev.B 50,23 (1994）；<br>Band theory and Mott insulators: Hubbard U instead of Stoner I, Phys.Rev.B. 44 No.3 (1991);<br>Materials Studio 4.3版本中也给出了一些元素默认的U数值（实际是Ueff＝U－J）：</p>
<table>
<thead>
<tr>
<th>Element Name</th>
<th>Atomic number</th>
<th>Angular Momentum</th>
<th>Hubbard U</th>
</tr>
</thead>
<tbody><tr>
<td>Sc</td>
<td>21</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Ti</td>
<td>22</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>V</td>
<td>23</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Cr</td>
<td>24</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Mn</td>
<td>25</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Fe</td>
<td>26</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Co</td>
<td>27</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Ni</td>
<td>28</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Cu</td>
<td>29</td>
<td>d</td>
<td>2.5 eV</td>
</tr>
<tr>
<td>Y</td>
<td>39</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Zr</td>
<td>40</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Nb</td>
<td>41</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Mo</td>
<td>42</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Tc</td>
<td>43</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Ru</td>
<td>44</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Rh</td>
<td>45</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Pd</td>
<td>46</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Ag</td>
<td>47</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Cd</td>
<td>48</td>
<td>d</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>La</td>
<td>57</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Ce</td>
<td>58</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Pr</td>
<td>59</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Nd</td>
<td>60</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Pm</td>
<td>61</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Sm</td>
<td>62</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Eu</td>
<td>63</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Gd</td>
<td>64</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Tb</td>
<td>65</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Dy</td>
<td>66</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Ho</td>
<td>67</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Er</td>
<td>68</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Tm</td>
<td>69</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Yb</td>
<td>70</td>
<td>f</td>
<td>6.0 eV</td>
</tr>
<tr>
<td>Fr</td>
<td>87</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Ra</td>
<td>88</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Ac</td>
<td>89</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Th</td>
<td>90</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Pa</td>
<td>91</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>U</td>
<td>92</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Np</td>
<td>93</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Pu</td>
<td>94</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Am</td>
<td>95</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Cm</td>
<td>96</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Bk</td>
<td>97</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Cf</td>
<td>98</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Es</td>
<td>99</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Fm</td>
<td>100</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>Md</td>
<td>101</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
<tr>
<td>No</td>
<td>102</td>
<td>f</td>
<td>2.0 eV</td>
</tr>
</tbody></table>
<p>LDAUU LDAUJ 两个参数是根据体系的POTCAR 中原子的种类来确定其值的个数，也就是说如果POTCAR 有三类原子的话，你想对其中的一类原子如V 加U 修正（假设加的U 为6.0V）的话，并且V 在POSCAR 中的顺序是 第2类原子，而其他元素的原子不想加U 的话，其相应值设为0 即可。</p>
<p>格式为：<br>LDAUU = 0.00  2.00  0.00<br>LDAUJ =  0.00  0.20  0.00</p>
<p>其他的:<br>LDAU =.TRUE.<br>LDAUTYPE = 2<br>LDAUL =-1  3   -1</p>
<p>LDAUPRING =2  ,此参数一般可以不设。</p>
<p>总之注意加 U 要和各种元素原子对应起来，这样才行。<br>LDAUJ 的值一般是LDAUU 值的1/10 或稍大一些，总之前者和后者差一个数量级。<br>LDAU = .TRUE. Switches on the L(S)DA+U.<br>• LDAUTYPE = 1|2|4 Type of L(S)DA+U (Default: LDAUTYPE = 2)<br>1 Rotationally invariant LSDA+U according to Liechtenstein et al.<br>4 Idem 1., but LDA+U instead of LSDA+U (i.e. no LSDA exchange splitting)<br>2 Dudarev’s approach to LSDA+U (Default)<br>• LDAUL = L .. l-quantum number for which the on site interaction is added<br>(-1: no on site terms added, 1: p, 2: d, 3: f, Default: LDAUL = 2)<br>• LDAUU = U .. Effective on site Coulomb interaction parameter<br>• LDAUJ = J .. Effective on</p>
]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>zotero快速复制引文</title>
    <url>/2020/08/26/zotero%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%BC%95%E6%96%87/</url>
    <content><![CDATA[<p>zetero技巧</p>
<a id="more"></a>

<p>选中zotero的任意一个文献，按command+shift+C (windows系统下：ctrl+shift+C), 再转到想插入文献的地方，按command+V, 就粘贴完成了，默认格式在首选项-导出里面设置</p>
<p>若想在PPT当中插入引用，这时候只需按command+shift+A, 再转到PPT中command+V进行粘贴即可</p>
]]></content>
      <categories>
        <category>论文写作</category>
      </categories>
  </entry>
  <entry>
    <title>过渡态计算</title>
    <url>/2020/08/24/%E8%BF%87%E6%B8%A1%E6%80%81%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>过渡态计算</p>
<a id="more"></a>

<p>1.建立两个名为begin和end的文件夹（名字随意，代表过度态的初始和结束状态），进行结构优化。</p>
<p>2.在平行于begin文件夹的目录下输入：</p>
<p><code>nebmake.pl begin/CONTCAR  end/CONTCAR  7</code></p>
<p>这行命令的意思是：利用nebmake脚本，以begin文件夹下的CONTCAR为初始结构，end文件夹下的CONTCAR为末态结构，在这个过度态过程中插入7个点。</p>
<p>3.将begin或end文件夹下的OUTCAR复制到00和08中，KPOINTS和POTCATR复制到00-08中。INCAR需要加入四个VASP相关的计算参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LCLIMB = .TRUE.</span><br><span class="line">IMAGES = 7</span><br><span class="line">SPRING = -5.0</span><br><span class="line">ICHAIN = 0</span><br></pre></td></tr></table></figure>

<p>4.提交任务</p>
<p><code>sbatch -N 7 vasp_neb.slurm</code></p>
<p>5.结果处理脚本:</p>
<p><code>nebresultsrev.pl</code></p>
]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>华为20200819电池组面试</title>
    <url>/2020/08/19/%E5%8D%8E%E4%B8%BA20200819%E7%94%B5%E6%B1%A0%E7%BB%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>上传几道陈荣汉的考试题</p>
<a id="more"></a>

<p><img src="/2020/08/19/%E5%8D%8E%E4%B8%BA20200819%E7%94%B5%E6%B1%A0%E7%BB%84%E9%9D%A2%E8%AF%95/lim.png" alt></p>
<p><img src="/2020/08/19/%E5%8D%8E%E4%B8%BA20200819%E7%94%B5%E6%B1%A0%E7%BB%84%E9%9D%A2%E8%AF%95/c.png" alt></p>
<p>哪个不是镍钴铝酸锂（NCA）正极材料存在的问题？</p>
<p>电池箱体采取密封圈密封时，影响密封性能的主要因素是什么？</p>
<p>离子液体的描述不正确的是？</p>
<p>下面关于SEI膜描述不正确的是？</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>VASP中的赝势</title>
    <url>/2020/08/18/VASP%E4%B8%AD%E7%9A%84%E8%B5%9D%E5%8A%BF/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="综述关系"><a href="#综述关系" class="headerlink" title="综述关系"></a>综述关系</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">赝势--&gt;模守恒赝势</span><br><span class="line">赝势--&gt;PAW投影缀加平面波</span><br><span class="line">赝势--&gt;USPP超软赝势</span><br><span class="line">PAW投影缀加平面波--&gt;LDA:局域密度泛函</span><br><span class="line">PAW投影缀加平面波--&gt;GGA:广义梯度泛函</span><br><span class="line">PAW投影缀加平面波--&gt;杂化泛函</span><br><span class="line">GGA:广义梯度泛函--&gt;PBE</span><br><span class="line">GGA:广义梯度泛函--&gt;PW91:一般不用</span><br></pre></td></tr></table></figure>



<blockquote>
<p>This work is based on the density functional theory (DFT) calculations performed by using the Vienna ab initio Simulation Package (VASP) software. The interaction between ion cores and valence electrons described by the projector augmented wave (PAW) method34. The generalized gradient approximation (GGA)35 in the form of Perdew–Burke–Ernzerhof (PBE) exchange functional36 was used to solve the quantum states of electron. The plane-wave energy cutoff is set to 500 eV. The Monkhorst–Pack method37 with 1 × 1 × 2 k-point mesh is employed for the Brillouin zone sampling of the super lattice. The convergence criteria of energy and force are set to 10−5 eV/atom and 0.01 eV/Å, respectively. The anion charges of lithium compounds were calculated by using the Atoms in Molecules method (Bader charge analysis)38. The energy variations and migration barriers of lithium ion migration in fcc-type anion sublattices with 48 anions (Supplementary Fig. 3) are calculated by the nudged elastic band (NEB) method39,40. The anion charges are changed by the uniform background charge of the sublattice system. Only the one migrating lithium ion is allowed to relax, while the other anions are fixed in their initial positions, and this method can be also found in Ceder’s work8 .</p>
</blockquote>
<p>文章中引用的时候需要五篇：DFT，PAW，GGA，PBE，VASP</p>
<h4 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h4><p>vasp计算中用到的三种赝势：模守恒赝势，超软赝势，PAW赝势(按产生顺序)。</p>
<p>按方法不同分为USPP（ultrasoft pesudopotential，超软赝势）和PAW（projector augmented wave，投影缀加平面波），两种方法都可以相当程度地减少过渡金属或第一行元素的每个原子所必需的平面波数量。</p>
<p>按交换关联函数不同分为LDA（local density approximation，局域密度近似）和GGA（generalized-gradient approximation，广义梯度近似），GGA又分为PW91（Perdew -Wang 91）和PBE（Perdew-Burke-Ernzerhof）。</p>
<p>求解K-S方程时电子之间的交换关联泛函取局域密度泛函LDA（Rc处电子结构当成是密度相同的均匀电子气体来算）。</p>
<p>广义梯度泛函GGA（考虑了密度的梯度变化），但泛函的不同也会引起贋势的不同。</p>
<ul>
<li>paw文件夹：PAW-LDA</li>
<li>paw_gga文件夹：PAW-GGA-PW91</li>
<li>paw_pbe文件夹：PAW-GGA-PBE</li>
<li>pot文件夹：USPP-LDA</li>
<li>pot_GGA文件夹：USPP-GGA</li>
</ul>
<p>选择某个目录进去，我们还会发现对应每种元素往往还会有多种赝势存在。这是因为根据ENMAX的大小还可以分为 Ga,Ga_s（soft）,Ga_h，或者根据处理半芯态的不同还可以分为Ga,Ga_sv（s电子作为半芯态）,Ga_pv的不同。</p>
<p>对于化合物（不同原子半径的元素混合）来说，PAW赝势比超软赝势精确度高。</p>
<p>US型赝势所需截至能较小，计算速度快，PAW赝势截至能通常较大，而且考虑的电子数多，计算慢，但精确度高。</p>
<p>在做具体的计算之前，针对需要计算的性质选取不同的贋势做下测试。对于不同贋势得到的结果，关注其最终的能量差，而不是绝对能量。</p>
]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵（剑指offer29）</title>
    <url>/2020/08/17/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># python3定义函数的格式，代表matrix中是一个列表，列表中还有列表，最里层列表中的元素是数字，返回是一个列表，其中也是数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix:[[int]])</span> -&gt; [int]:</span></span><br><span class="line">        <span class="comment"># 检查是否为空矩阵</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 初始化上下左右四个边界值</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        b = len(matrix) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 这是一个永久循环，一直到break执行，如果没有这句只会执行最外面的一层</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>): res.append(matrix[t][i]) <span class="comment"># left to right</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>): res.append(matrix[i][r]) <span class="comment"># top to bottom</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>): res.append(matrix[b][i]) <span class="comment"># right to left</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>): res.append(matrix[i][l]) <span class="comment"># bottom to top</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="While-True的作用"><a href="#While-True的作用" class="headerlink" title="While True的作用"></a>While True的作用</h5><h5 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h5><p>range函数有三个参数<code>range(start, stop[, step])</code>, 一般来说range函数默认从0开始，第一额参数显示，最后一个参数不显示，若步长为-1则需要start大于stop</p>
<h5 id="类和函数的区别及调用，self的作用"><a href="#类和函数的区别及调用，self的作用" class="headerlink" title="类和函数的区别及调用，self的作用"></a>类和函数的区别及调用，self的作用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matirix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line"><span class="comment"># 初始化一个类并且调用这个类下的函数</span></span><br><span class="line">s = Solution()</span><br><span class="line">s.spiralOrder(matirix)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>相图分析的一般套路</title>
    <url>/2020/08/12/%E7%9B%B8%E5%9B%BE%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>本文包括相图分析的一般方法。</p>
<a id="more"></a>

<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>本文主要涉及二元相图（合金成分和温度的相图），主要顺序为：<code>找到单相区-&gt;找到两项区-&gt;分析包晶，共晶，共析反应</code></p>
<h4 id="单相区与两相区"><a href="#单相区与两相区" class="headerlink" title="单相区与两相区"></a>单相区与两相区</h4><p>单相区相图中会直接标出，两相区是两个单相区的交集，三相区是一条直线。</p>
<h4 id="反应的类型"><a href="#反应的类型" class="headerlink" title="反应的类型"></a>反应的类型</h4><p>包晶：<code>L+S-&gt;S</code> 开口向下</p>
<p>共晶：<code>L-&gt;S1+S2</code> 开口向上</p>
<p>共析：<code>S1-&gt;S2+S3</code> 开口向上</p>
]]></content>
      <categories>
        <category>材料科学基础</category>
      </categories>
  </entry>
  <entry>
    <title>IamD课题组打印机配置</title>
    <url>/2020/08/12/IamD%E8%AF%BE%E9%A2%98%E7%BB%84%E6%89%93%E5%8D%B0%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>本文内含课题组打印机配置方法</p>
<a id="more"></a>

<h4 id="打印机的连接"><a href="#打印机的连接" class="headerlink" title="打印机的连接"></a>打印机的连接</h4><p>当前打印机通过 NAS 连入局域网，因此使用打印机也需要网线接入局域网，即需要插有线网。</p>
<p>打印机型号：<code>Fuji Xerox DocuPrint P268 dw</code></p>
<h4 id="Windows连接打印机"><a href="#Windows连接打印机" class="headerlink" title="Windows连接打印机"></a>Windows连接打印机</h4><p>首先在官方网站安装好打印机驱动</p>
<blockquote>
<p>Win10 驱动直接下载链接 (Apr.18.2019):</p>
<p><a href="http://onlinesupport.fujixerox.com//driver_downloads/fxdm228_268pcl6150320wxpcizh.zip" target="_blank" rel="noopener">http://onlinesupport.fujixerox.com//driver_downloads/fxdm228_268pcl6150320wxpcizh.zip</a></p>
</blockquote>
<p>装好驱动后，参考 <a href="https://www.synology.com/zh-cn/knowledgebase/DSM/help/DSM/AdminCenter/system_externaldevice_printer" target="_blank" rel="noopener">打印机 - 外接设备| Synology群晖科技官网</a> 类型 2.LPR Port 进行设置。</p>
<p>注意在添加打印机的时候要选择共享打印机，按照TCP/IP无法添加。（Aug.11.2020 唐师姐踩坑）</p>
<img src="/2020/08/12/IamD%E8%AF%BE%E9%A2%98%E7%BB%84%E6%89%93%E5%8D%B0%E6%9C%BA%E9%85%8D%E7%BD%AE/printer.png" style="zoom:50%;">]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>0_python入门基本准备</title>
    <url>/2020/08/08/0_python%E5%85%A5%E9%97%A8%E5%9F%BA%E6%9C%AC%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h3><ul>
<li>一门能让程序从数据中学习的计算机科学</li>
<li>机器学习让计算机写函数（台大李宏毅）</li>
</ul>
<h3 id="Anaconda安装python环境"><a href="#Anaconda安装python环境" class="headerlink" title="Anaconda安装python环境"></a>Anaconda安装python环境</h3><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>矩阵：h行（h个样本） w列（w个特征）</p>
]]></content>
      <categories>
        <category>python数据分析与机器学习实战-唐宇迪</category>
      </categories>
  </entry>
  <entry>
    <title>课程大纲</title>
    <url>/2020/08/08/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2md/</url>
    <content><![CDATA[<p>本文包括唐宇迪python数据分析与机器学习实战目录</p>
<a id="more"></a>

<h3 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h3><p><a href="https://www.bilibili.com/video/BV1gb411h7nn?from=search&seid=7630101371083347922" target="_blank" rel="noopener">【唐宇迪】Python数据分析与机器学习实战</a></p>
<ol>
<li>Numpy（矩阵运算）</li>
<li>Pandas（数据分析处理）</li>
<li>Matplotlib（基本画图库）</li>
<li>Seaborn（适用于复杂图的画图库）</li>
<li>回归算法</li>
<li>决策树</li>
<li>贝叶斯算法</li>
<li>支持向量机</li>
<li>神经网络</li>
<li>Xgboost集成算法</li>
<li>自然语言处理向量模型</li>
<li>K近邻与聚类</li>
<li>PCA降维与SVD矩阵分解</li>
<li>scikit-learn模型建立与评估</li>
<li>Python库分析科比生涯数据</li>
<li>机器学习实战-泰坦尼克号船员获救（二分类问题）</li>
<li>机器学习实战-交易数据异常（数据样本不均衡，模型评估标准）</li>
<li>实用Gensim库构造中文维基百度</li>
<li>机器学习项目实战-贷款申请最大</li>
<li>机器学习项目实战-用户流失预警</li>
<li>探索性数据分析（EDA）-足球赛事数据集</li>
<li>探索性数据分析（EDA）-农粮组织数据集</li>
<li>机器学习项目实战-HTTP日志</li>
</ol>
]]></content>
      <categories>
        <category>python数据分析与机器学习实战-唐宇迪</category>
      </categories>
  </entry>
  <entry>
    <title>python合并pdf文件</title>
    <url>/2020/08/08/python%E5%90%88%E5%B9%B6pdf%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>本文包括python合并pdf相关脚本</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8*-</span></span><br><span class="line"><span class="comment"># 利用PyPDF2模块合并同一文件夹下的所有PDF文件</span></span><br><span class="line"><span class="comment"># 只需修改存放PDF文件的文件夹变量：filepath 和 输出文件名变量: name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader, PdfFileWriter</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用os模块的walk函数，搜索出指定目录下的全部PDF文件</span></span><br><span class="line"><span class="comment"># 获取同一目录下的所有PDF文件的绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFileName</span><span class="params">(filedir)</span>:</span></span><br><span class="line"></span><br><span class="line">    file_list = [os.path.join(root, filespath) \</span><br><span class="line">                 <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(filedir) \</span><br><span class="line">                 <span class="keyword">for</span> filespath <span class="keyword">in</span> files \</span><br><span class="line">                 <span class="keyword">if</span> str(filespath).endswith(<span class="string">'pdf'</span>)</span><br><span class="line">                 ]</span><br><span class="line">    <span class="keyword">return</span> file_list <span class="keyword">if</span> file_list <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并同一目录下的所有PDF文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergePDF</span><span class="params">(filepath, outfile)</span>:</span></span><br><span class="line"></span><br><span class="line">    output = PdfFileWriter()</span><br><span class="line">    outputPages = <span class="number">0</span></span><br><span class="line">    pdf_fileName = getFileName(filepath)</span><br><span class="line">    <span class="comment"># 将pdf文件按照命名排序</span></span><br><span class="line">    pdf_fileName.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pdf_fileName:</span><br><span class="line">        <span class="keyword">for</span> pdf_file <span class="keyword">in</span> pdf_fileName:</span><br><span class="line">            print(<span class="string">"路径：%s"</span>%pdf_file)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 读取源PDF文件</span></span><br><span class="line">            input = PdfFileReader(open(pdf_file, <span class="string">"rb"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获得源PDF文件中页面总数</span></span><br><span class="line">            pageCount = input.getNumPages()</span><br><span class="line">            outputPages += pageCount</span><br><span class="line">            print(<span class="string">"页数：%d"</span>%pageCount)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分别将page添加到输出output中</span></span><br><span class="line">            <span class="keyword">for</span> iPage <span class="keyword">in</span> range(pageCount):</span><br><span class="line">                output.addPage(input.getPage(iPage))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"合并后的总页数:%d."</span>%outputPages)</span><br><span class="line">        <span class="comment"># 写入到目标PDF文件</span></span><br><span class="line">        outputStream = open(os.path.join(filepath, outfile), <span class="string">"wb"</span>)</span><br><span class="line">        output.write(outputStream)</span><br><span class="line">        outputStream.close()</span><br><span class="line">        print(<span class="string">"PDF文件合并完成！"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"没有可以合并的PDF文件！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数，输入文件地址和输出的名称</span></span><br><span class="line">filepath = os.getcwd() </span><br><span class="line">name = <span class="string">"材料分析"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    time1 = time.time()</span><br><span class="line">    file_dir = filepath <span class="comment"># 存放PDF的原文件夹</span></span><br><span class="line">    outfile = name+<span class="string">"汇总.pdf"</span> <span class="comment"># 输出的PDF文件的名称</span></span><br><span class="line">    MergePDF(file_dir, outfile)</span><br><span class="line">    time2 = time.time()</span><br><span class="line">    print(<span class="string">'总共耗时：%s s.'</span> %(time2 - time1))</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>预测模型评价指标</title>
    <url>/2020/07/20/%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>MSE，RMSE，MAE，MARE误差分析</p>
<a id="more"></a>

<h4 id="MSE（Mean-Square-Error）均方误差"><a href="#MSE（Mean-Square-Error）均方误差" class="headerlink" title="MSE（Mean Square Error）均方误差"></a>MSE（Mean Square Error）均方误差</h4><p>$$MSE=\frac{1}{n}\sum_{i=0}^n(y_i-y_{i,pred})^2$$</p>
<h4 id="RMSE（Root-Mean-Square-Error）均方根误差"><a href="#RMSE（Root-Mean-Square-Error）均方根误差" class="headerlink" title="RMSE（Root Mean Square Error）均方根误差"></a>RMSE（Root Mean Square Error）均方根误差</h4><p>$$RMSE=\sqrt{\frac{1}{n}\sum_{i=0}^n(y_i-y_{i,pred})^2}$$</p>
<h4 id="MAE-Mean-absolute-error-平均绝对误差"><a href="#MAE-Mean-absolute-error-平均绝对误差" class="headerlink" title="MAE(Mean absolute error)平均绝对误差"></a>MAE(Mean absolute error)平均绝对误差</h4><p>$$MAE=\frac{1}{m}\sum_{i=0}^n|y_i-y_{i,pred}|$$</p>
<h4 id="MARE-Mean-absolute-relative-error"><a href="#MARE-Mean-absolute-relative-error" class="headerlink" title="MARE(Mean absolute relative error)"></a>MARE(Mean absolute relative error)</h4><p>$$MARE=\frac{1}{m}\sum_{i=0}^n|\frac{y_i-y_{i,pred}}{y_i}|$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>决定系数R^2</title>
    <url>/2020/07/20/%E5%86%B3%E5%AE%9A%E7%B3%BB%E6%95%B0R-2/</url>
    <content><![CDATA[<p><strong>coefficient of</strong> <strong>determination</strong>决定系数$R^2$，也称判定系数，拟合优度。用来衡量回归的好坏</p>
<a id="more"></a>

<h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>设y为真实的数据，其平均值为$ \bar y$，拟合值(预测值)为$ \hat y$</p>
<p>总平方和（SST）：$\sum_{i=0}^n(y_i-\bar y)^2$<br>回归平方和（SSR）：$\sum_{i=0}^n(\hat y_i-\bar y)^2$<br>残差平方和（SSE）：$\sum_{i=0}^n(y_i-\hat y)^2$</p>
<p>由于关系式：SST=SSR+SSE，所以决定系数：</p>
<p>$$R^2=\frac{SSR}{SST}=1-\frac{SSE}{SST}=1-\frac{\sum_{i=0}^n(y_i-\hat y)^2}{\sum_{i=0}^n(y_i-\bar y)^2}$$</p>
<p>决定系数越大表拟合优度越好!</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2020/07/14/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>线性回归的相关方法</p>
<a id="more"></a>

<h5 id="所用函数"><a href="#所用函数" class="headerlink" title="所用函数"></a>所用函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LinearRegression() <span class="comment">#所需参数</span></span><br><span class="line">- fit_intercept:</span><br><span class="line">-</span><br></pre></td></tr></table></figure>

<h5 id="确定是否存在线性关系"><a href="#确定是否存在线性关系" class="headerlink" title="确定是否存在线性关系"></a>确定是否存在线性关系</h5><ul>
<li>散点图直接观察</li>
<li></li>
</ul>
<h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>多项式回归，具有多个自变量。不同于线性回归，我们是使用曲线做回归。</p>
<p>一元多项式和多元多项式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建多项式特征</span></span><br><span class="line">sklearn.preprocessing.PolynomialFeatures()</span><br></pre></td></tr></table></figure>



<h4 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h4>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>word公式自动编号</title>
    <url>/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>不需要任何插件的论文公式自动编号方法</p>
<a id="more"></a>

<h5 id="按照插入-公式的方法插入公式"><a href="#按照插入-公式的方法插入公式" class="headerlink" title="按照插入-公式的方法插入公式"></a>按照插入-公式的方法插入公式</h5><p><img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/1.png" alt></p>
<h5 id="在公式最后加英文"><a href="#在公式最后加英文" class="headerlink" title="在公式最后加英文#()"></a>在公式最后加英文#()</h5><img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/2.png" style="zoom:50%;">

<h5 id="在括号内添加：1插入-2域-3编号-4AutoNum"><a href="#在括号内添加：1插入-2域-3编号-4AutoNum" class="headerlink" title="在括号内添加：1插入-2域-3编号-4AutoNum"></a>在括号内添加：1插入-2域-3编号-4AutoNum</h5><img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/3-1.png" style="zoom:50%;">

<img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/3-2.png" style="zoom:50%;">

<img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/3-3.png" style="zoom:50%;">

<h5 id="复制-1-在括号内最后面点击回车并删掉换行符"><a href="#复制-1-在括号内最后面点击回车并删掉换行符" class="headerlink" title="复制#(1),在括号内最后面点击回车并删掉换行符"></a>复制#(1),在括号内最后面点击回车并删掉换行符</h5><img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/4.png" style="zoom:50%;">

<p>我们发现公式自动居中并且编号右对齐了。</p>
<h5 id="粘贴-1-这时会发现编号自动变成了-2-，重复操作"><a href="#粘贴-1-这时会发现编号自动变成了-2-，重复操作" class="headerlink" title="粘贴#(1),这时会发现编号自动变成了#(2)，重复操作"></a>粘贴#(1),这时会发现编号自动变成了#(2)，重复操作</h5><img src="/2020/07/13/word%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/5.png" style="zoom:50%;">

<h5 id="完成！此方法支持随意插入和删除，编号会自动改变！！！"><a href="#完成！此方法支持随意插入和删除，编号会自动改变！！！" class="headerlink" title="完成！此方法支持随意插入和删除，编号会自动改变！！！"></a>完成！此方法支持随意插入和删除，编号会自动改变！！！</h5><h3 id="20200831更新"><a href="#20200831更新" class="headerlink" title="20200831更新"></a>20200831更新</h3><p>若多次更新公式导致序号混乱可以直接在括号里面改正。</p>
]]></content>
      <categories>
        <category>论文写作</category>
      </categories>
  </entry>
  <entry>
    <title>科学跑步</title>
    <url>/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p>本文总结了跑步相关的注意事项</p>
<a id="more"></a>

<p>跑步的时间：个人最喜欢下午4:30</p>
<p>前脚掌着地</p>
<h4 id="跑后拉伸-从下肢到胳膊再到躯干"><a href="#跑后拉伸-从下肢到胳膊再到躯干" class="headerlink" title="跑后拉伸-从下肢到胳膊再到躯干"></a>跑后拉伸-从下肢到胳膊再到躯干</h4><ul>
<li><strong>髋部拉伸</strong>：单脚向前跨步，后腿撑直，臀部向下尽力往下用力，全面打开髋部，感受髋部拉伸感。保持10秒后换腿伸展。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/kuan.gif" alt></p>
<ul>
<li><strong>臀部拉伸</strong>：双腿并拢伸直，上身平直向前弯曲，双手放至小腿保持平衡，抬头看向前方，腰部不要弯曲，感受臀部肌肉拉伸。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/tun.gif" alt></p>
<ul>
<li><strong>大腿后侧拉伸：</strong>双腿并拢伸直，上身平直向前向下弯曲，腹部平贴大腿面，双手放至脚踝将身体拉近，拉伸至最大限度保持即可，切不可追求拉伸幅度，拉伸过度！</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/datuihou.gif" alt></p>
<ul>
<li><strong>腿部及后侧及后背拉伸</strong>：四脚撑地，双腿打开两个肩宽，后背平直下压，双脚交替抬起及下落，感受腿部后侧及后背的拉伸感，感受腋窝展开的舒适感。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/tuibu.gif" alt></p>
<ul>
<li><strong>小腿拉伸：</strong>单腿向前脚尖抬起，腹部贴至大腿根部，双手将脚尖向上掰起，小腿感受强烈的拉伸感。保持10秒后换脚继续。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/xiaotui.jpg" alt></p>
<ul>
<li>大腿前侧拉伸：身体站直，双手在身后拉起一只脚，用力靠近身体。单腿站立，保持平衡。保持10秒以上后换腿，拉伸，感受大腿前侧肌肉拉伸感觉。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/%E5%A4%A7%E8%85%BF%E5%89%8D.gif" alt></p>
<ul>
<li><strong>手臂拉伸</strong></li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/shou1.gif" alt="科学跑步"></p>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/shou2.gif" alt="科学跑步"></p>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/shou3.gif" alt="科学跑步"></p>
<ul>
<li>后背拉伸：双腿打开两个肩宽，双手在背后握拳，身体向下折叠，手臂向上用力拉伸至极限，感受腰部、后背和腋窝处的拉伸感。</li>
</ul>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/houbei.gif" alt></p>
<ul>
<li><p>全身串联</p>
<p><img src="/2020/07/01/%E7%A7%91%E5%AD%A6%E8%B7%91%E6%AD%A5/quanshen.gif" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>材料中可以分析的因素</title>
    <url>/2020/06/30/%E6%9D%90%E6%96%99%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%86%E6%9E%90%E7%9A%84%E5%9B%A0%E7%B4%A0/</url>
    <content><![CDATA[<p>本文总结了做相关性分析的所有影响因素</p>
<a id="more"></a>

<h4 id="常规的分析"><a href="#常规的分析" class="headerlink" title="常规的分析"></a>常规的分析</h4><p>原子的性质：半径，原子序数，重量</p>
<p>原子的化学性质：电负性，电离能，电子亲合能</p>
<p>物理性质：第二相的密度</p>
<p>电子性质：能带，导电性</p>
<p>第二相性质：熔点，沸点，生成焓</p>
<h4 id="海水腐蚀中海水的影响因素"><a href="#海水腐蚀中海水的影响因素" class="headerlink" title="海水腐蚀中海水的影响因素"></a>海水腐蚀中海水的影响因素</h4><p>浸泡时间，温度，海水导电性，pH，含盐量，溶氧量，海水流速</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>皮尔逊相关系数</title>
    <url>/2020/06/29/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
    <content><![CDATA[<p>本文包括相关性分析-PCC皮尔逊相关系数内容及python代码实现</p>
<a id="more"></a>

<h4 id="什么是相关？"><a href="#什么是相关？" class="headerlink" title="什么是相关？"></a>什么是相关？</h4><blockquote>
<p><strong>相关</strong>（Correlation，或称<strong>相关系数</strong>或<strong>关联系数</strong>），显示两个<a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F">随机变量</a>之间<strong>线性</strong>关系的强度和方向。</p>
</blockquote>
<p>所以当我们谈到相关，我们谈的就是线性相关。相关系数也有很多种，一般常用的是Pearson相关系数 (<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient">Pearson product-moment correlation coefficient</a>)，在 -1 到 +1 之间，其中 +1 表示完全线性正相关，-1 为完全线性负相关， 0 为线性不相关。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><blockquote>
<p>计算特征与目标变量之间的相关度</p>
</blockquote>
<h4 id="函数代码实现"><a href="#函数代码实现" class="headerlink" title="函数代码实现"></a>函数代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line">pearsonr(x, y) <span class="comment">#x，y为两个数字列表</span></span><br></pre></td></tr></table></figure>

<h4 id="输入和返回值"><a href="#输入和返回值" class="headerlink" title="输入和返回值"></a>输入和返回值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)输入：x为特征，y为目标变量.在我第一次用的时候，x为吸附能，y为成键原子个数，晶体方向，bader等等</span><br><span class="line">(<span class="number">2</span>)输出：r：相关系数 [<span class="number">-1</span>，<span class="number">1</span>]之间。一般用r分析即可，大于<span class="number">0</span>正相关，小于<span class="number">0</span>负相关，绝对值越靠近<span class="number">1</span>相关性越大。</span><br><span class="line">p-value: p值。p值越小，表示相关系数越显著，一般p值在<span class="number">500</span>个样本以上时有较高的可靠性。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>numpy与Pandas常见操作</title>
    <url>/2020/06/29/numpy%E4%B8%8EPandas%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本文包括numpy与Pandas常见操作</p>
<a id="more"></a>

<h4 id="读取与保存CSV文件"><a href="#读取与保存CSV文件" class="headerlink" title="读取与保存CSV文件"></a>读取与保存CSV文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">'rawdata.xlsx'</span>)</span><br><span class="line">df.to_excel(<span class="string">'test.xls'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="获取DataFrame行名"><a href="#获取DataFrame行名" class="headerlink" title="获取DataFrame行名"></a>获取DataFrame行名</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns.values.tolist() <span class="comment">#列名称，获取得到一个列表</span></span><br><span class="line">dfname._stat_axis.values.tolist() <span class="comment"># 行名称</span></span><br></pre></td></tr></table></figure>

<h4 id="DataFrame按照某一行排序"><a href="#DataFrame按照某一行排序" class="headerlink" title="DataFrame按照某一行排序"></a>DataFrame按照某一行排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df2.sort_values(by=[<span class="string">'index_r'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="绘制水平bar图"><a href="#绘制水平bar图" class="headerlink" title="绘制水平bar图"></a>绘制水平bar图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.barh(df[<span class="string">'Names'</span>],df[<span class="string">'index_r'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="将数据保存到DataFrame中的方法"><a href="#将数据保存到DataFrame中的方法" class="headerlink" title="将数据保存到DataFrame中的方法"></a>将数据保存到DataFrame中的方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_r = []</span><br><span class="line">index_p = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> names:</span><br><span class="line">    print(n,pearsonr(x, df[n]))</span><br><span class="line">    index_r.append(pearsonr(x, df[n])[<span class="number">0</span>])</span><br><span class="line">    index_p.append(pearsonr(x, df[n])[<span class="number">1</span>])</span><br><span class="line">dataset = list(zip(names,index_r,index_p))</span><br><span class="line">df2 = pd.DataFrame(data = dataset,columns=[<span class="string">'Names'</span>,<span class="string">'index_r'</span>,<span class="string">'index_p'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="从github上读取CSV"><a href="#从github上读取CSV" class="headerlink" title="从github上读取CSV"></a>从github上读取CSV</h4><p>点击raw才可以读出来</p>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>VASPKIT安装</title>
    <url>/2020/06/28/VASPKIT%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="下载安装包并解压上传集群"><a href="#下载安装包并解压上传集群" class="headerlink" title="下载安装包并解压上传集群"></a>下载安装包并解压上传集群</h3><p><a href="http://vaspkit.sourceforge.net/" target="_blank" rel="noopener">http://vaspkit.sourceforge.net/</a></p>
<h3 id="进入到安装包文件夹并配置环境"><a href="#进入到安装包文件夹并配置环境" class="headerlink" title="进入到安装包文件夹并配置环境"></a>进入到安装包文件夹并配置环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/lustre/home/acct-umjzhh/umjzhh-3/opt/vaspkit.1.12:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">vim how_to_set_environment_variable  <span class="comment">#修改一下三行到势函数的位置</span></span><br><span class="line">LDA_PATH                      ~/POTCAR/LDA       <span class="comment">#  Path of LDA potential.</span></span><br><span class="line">PBE_PATH                      ~/POTCAR/PBE       <span class="comment">#  Path of PBE potential.</span></span><br><span class="line">PW91_PATH                     ~/POTCAR/PW91      <span class="comment">#  Path of PW91 potential.</span></span><br></pre></td></tr></table></figure>

<h3 id="运行安装命令"><a href="#运行安装命令" class="headerlink" title="运行安装命令"></a>运行安装命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash setup.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>论文写作</title>
    <url>/2020/06/24/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>Author：<a href="mailto:mrimi@aps.org">mrimi@aps.org</a></p>
</blockquote>
<p>本文内含APS编辑分享投稿经验</p>
<a id="more"></a>

<h2 id="How-to-write-a-great-scientific-paper"><a href="#How-to-write-a-great-scientific-paper" class="headerlink" title="How to write a great scientific paper"></a>How to write a great scientific paper</h2><h3 id="How-to-write-a-paper"><a href="#How-to-write-a-paper" class="headerlink" title="How to write a paper?"></a>How to write a paper?</h3><h4 id="Find-the-best-science"><a href="#Find-the-best-science" class="headerlink" title="Find the best science"></a>Find the best science</h4><ol>
<li><strong>MOTIVASTION</strong>-Why this research?</li>
<li><strong>OPEN QUESTION</strong>-What are the specific research needs?</li>
<li><strong>KEY RESULT</strong>-What is really new?</li>
<li><strong>IMPACT</strong>-What are the implications of the result?</li>
</ol>
<h4 id="Overcome-writing-challenges"><a href="#Overcome-writing-challenges" class="headerlink" title="Overcome writing challenges"></a>Overcome writing challenges</h4><ol>
<li>Write with the reader in mind</li>
<li>Practice</li>
<li>Read, read, read!(读的多才能写得好：语言，组织结构)</li>
<li>Speaking well not equals to writing well, be confident</li>
</ol>
<h4 id="Stages-of-writing"><a href="#Stages-of-writing" class="headerlink" title="Stages of writing"></a>Stages of writing</h4><p><strong>(1) Find the story - writing is storytelling</strong></p>
<ul>
<li>What srory do you want to tell?</li>
<li>telling a stary is more than presneting results</li>
<li>wat results/experiments are necessary to tell your story?</li>
<li>Every paper tells one story</li>
</ul>
<p><strong>(2) Build the structure</strong></p>
<ul>
<li>use a logic-flow diagram</li>
<li>paragraph = unit of thought</li>
</ul>
<p>eg. Structure example</p>
<p>Each parafgraph shopuld tell a complete story</p>
<p>Each paragraph has an internal structure(Point first and last paragraph)</p>
<p>Give titles to paragraphs</p>
<p><strong>(3) Find the best language for the story</strong></p>
<ul>
<li><p>Don not speak in a stuffy manner for a judgmental</p>
</li>
<li><p>Economy and highlights(越精确越短越好，少用副词，少用术语，写短句子)</p>
</li>
<li><p>the whole structure of paper</p>
</li>
</ul>
<img src="/2020/06/24/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/structure.png" style="zoom:35%;">

<h3 id="How-to-write-a-cover-letter"><a href="#How-to-write-a-cover-letter" class="headerlink" title="How to write a cover letter?"></a>How to write a cover letter?</h3><h4 id="Point-to-convery"><a href="#Point-to-convery" class="headerlink" title="Point to convery"></a>Point to convery</h4><ul>
<li>Why the work was done, what’s the improvement over previous work and what are the implications, you can mention some relevant previous work.</li>
<li>Why it is appropriare for the specific journal, and not a more specialized journal</li>
<li>do not explain too much technical details in cover letter</li>
<li>claim the work is important and suitable for specific journal and always *<u>explain the reason</u>*</li>
</ul>
<h4 id="Some-tips"><a href="#Some-tips" class="headerlink" title="Some tips"></a>Some tips</h4><ul>
<li>It’s directed to the editors, target to them !</li>
<li>Usually the referees won’t see it</li>
<li>Short!(1 page max)</li>
<li>Use it disclose confidential information</li>
<li>Do not copy and paste the abstract</li>
<li>For most journals, it’s optional, but it’s always recoomended.</li>
</ul>
<h3 id="为啥审稿周期这么长？"><a href="#为啥审稿周期这么长？" class="headerlink" title="为啥审稿周期这么长？"></a>为啥审稿周期这么长？</h3><ul>
<li>远程办公，不能保持及时性</li>
<li>审稿人有自己的工作，大咖们会比较忙</li>
<li>很多因素共同作用下导致这样的原因</li>
</ul>
]]></content>
      <categories>
        <category>论文写作</category>
      </categories>
  </entry>
  <entry>
    <title>chkdsk移动硬盘修复方法</title>
    <url>/2020/06/23/chkdsk%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文内含chkdsk移动硬盘修复方法</p>
<a id="more"></a>

<p>2020年6月23日，跟随了我三年的1T移动硬盘莫名其妙的坏掉了。具体表现为插到电脑上能显示磁盘，但是无内存大小显示。</p>
<p><img src="/2020/06/23/chkdsk%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/hard_drive.png" alt></p>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><ol>
<li>windows操作系统下输入cmd，以管理员权限运行（否则可能会出现权限不足的情况）</li>
<li>输入：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkdsk L： /R</span><br></pre></td></tr></table></figure>

<p>其中L为失效的磁盘位置。</p>
<h4 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h4><p>运行的速度很慢，目前终端中展示如下，据说一共有5步，期待一下明早会被修复：</p>
<p><img src="/2020/06/23/chkdsk%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/terminal.png" alt></p>
]]></content>
      <categories>
        <category>Linux操作系统与常用软件</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 三步解决免密登录</title>
    <url>/2020/06/22/SSH-%E4%B8%89%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>本文内含SSH免密登陆方法</p>
<a id="more"></a>

<h3 id="生成私钥文件"><a href="#生成私钥文件" class="headerlink" title="生成私钥文件"></a>生成私钥文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>终端中输入以上命令一路回车就好</p>
<h3 id="将本地公匙增加到集群中"><a href="#将本地公匙增加到集群中" class="headerlink" title="将本地公匙增加到集群中"></a>将本地公匙增加到集群中</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">拷贝内容到集群~/.ssh/authorized_keys中（自已不要覆盖其他人的信息）</span><br></pre></td></tr></table></figure>

<h3 id="利用alias命令简化登陆"><a href="#利用alias命令简化登陆" class="headerlink" title="利用alias命令简化登陆"></a>利用alias命令简化登陆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">alias</span> = <span class="built_in">alias</span> tji=<span class="string">'ssh -p 3391 um008@202.121.180.10'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux操作系统与常用软件</category>
      </categories>
  </entry>
  <entry>
    <title>做PPT注意事项</title>
    <url>/2020/06/22/%E5%81%9APPT%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>本文内含多年的PPT经验总结</p>
<a id="more"></a>

<ol>
<li>加页码</li>
<li>参考文献</li>
<li>图片不是自己的都要加饮用</li>
</ol>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>数据处理常见操作</title>
    <url>/2020/06/17/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>腐蚀动力学</title>
    <url>/2020/06/16/%E8%85%90%E8%9A%80%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
    <content><![CDATA[<blockquote>
<p> Introduction to corrosion science-E.McCafferty, P127</p>
</blockquote>
<h4 id="Overpotential"><a href="#Overpotential" class="headerlink" title="Overpotential"></a>Overpotential</h4><p>$\eta = E-E_o$</p>
<p>where E is the electrode potential for some condition of current flow and $E_o$ is the electrode potential for zero current flow (also called the open-circuit potential, corrosion potential). Note that the electrode potential of zero current flow Eo should not be confused with the standard electrode potential $E^o$, which plays a prominent role in corrosion thermodynamics.</p>
<h4 id="Absolute-Reaction-Rate-Theory"><a href="#Absolute-Reaction-Rate-Theory" class="headerlink" title="Absolute Reaction Rate Theory"></a>Absolute Reaction Rate Theory</h4>]]></content>
      <tags>
        <tag>腐蚀科学</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客维护</title>
    <url>/2020/06/16/hexo%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p>本文包括博客运营过程中的常见问题及解决方案</p>
<a id="more"></a>

<h4 id="摘要写法"><a href="#摘要写法" class="headerlink" title="摘要写法"></a>摘要写法</h4><p><code>&lt;!-- more --&gt;</code></p>
<h4 id="插入图片方法"><a href="#插入图片方法" class="headerlink" title="插入图片方法"></a>插入图片方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> hexo new <span class="string">'file_name'</span></span><br><span class="line"><span class="number">2.</span> 将图片放如生成的<span class="string">'file_name'</span>文件夹</span><br><span class="line"><span class="number">3.</span> ![](file_name/pic_name.jpg)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Bug调试</tag>
      </tags>
  </entry>
  <entry>
    <title>SCI作图模版</title>
    <url>/2020/06/16/SCI%E4%BD%9C%E5%9B%BE%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<p>本文内容为python matplotlib包总结的SCI论文模版，内容不全面，不断更新中……</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> * <span class="comment">#控制刻度线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#格式设置区域</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8.3</span>,<span class="number">6</span>))<span class="comment">#图片大小设置</span></span><br><span class="line">label_font = &#123;<span class="string">'family'</span>:<span class="string">'Arial'</span>,<span class="string">'weight'</span>:<span class="string">'normal'</span>,<span class="string">'size'</span>:<span class="number">22</span>&#125;<span class="comment">#设置标签和图例字体</span></span><br><span class="line">legend_font = &#123;<span class="string">'family'</span>:<span class="string">'Arial'</span>,<span class="string">'weight'</span>:<span class="string">'normal'</span>,<span class="string">'size'</span>:<span class="number">12</span>&#125;</span><br><span class="line">plt.xlabel(<span class="string">'Vacancy at n layer'</span>,label_font)</span><br><span class="line">plt.ylabel(<span class="string">'Vacancy formation energy (ev)'</span>,label_font)</span><br><span class="line">plt.yticks(fontproperties = <span class="string">'Arial'</span>, size = <span class="number">18</span>)</span><br><span class="line">plt.xticks(fontproperties = <span class="string">'Arial'</span>, size = <span class="number">18</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">1</span>, <span class="number">5.1</span>, <span class="number">1</span>))<span class="comment">#横坐标范围及间隔</span></span><br><span class="line">matplotlib.rcParams[<span class="string">'patch.linewidth'</span>] = <span class="number">1.5</span><span class="comment">#图例边框线宽度</span></span><br><span class="line">plt.rcParams[<span class="string">'xtick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将x周的刻度线方向设置向内</span></span><br><span class="line">plt.rcParams[<span class="string">'ytick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将y轴的刻度方向设置向内</span></span><br><span class="line">plt.tick_params(which=<span class="string">'major'</span>,width=<span class="number">2</span>,length=<span class="number">6</span>)<span class="comment">#设置刻度线宽度</span></span><br><span class="line">bwith = <span class="number">2</span><span class="comment">#加粗图四周边框</span></span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_linewidth(bwith)    </span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_linewidth(bwith)</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_linewidth(bwith)  </span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_linewidth(bwith) </span><br><span class="line">ms = <span class="number">12</span> <span class="comment">#标记符号大小</span></span><br><span class="line">ld = <span class="number">1.5</span> <span class="comment">#线宽度</span></span><br><span class="line">mew = <span class="number">1</span> <span class="comment">#标记边框线宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############Plot input region#################</span></span><br><span class="line">name = <span class="string">'fig2_vfe'</span></span><br><span class="line">style = <span class="string">'pdf'</span><span class="comment">#设置图片格式</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">0.672943</span>,<span class="number">1.024707</span>,<span class="number">0.891641</span>,<span class="number">0.898325</span>,<span class="number">0.868871</span>]</span><br><span class="line">y2 = [<span class="number">11.38964</span>,<span class="number">12.06575</span>,<span class="number">11.69664</span>,<span class="number">12.57189</span>,<span class="number">12.57274</span>]</span><br><span class="line">y3 = [<span class="number">1.13963</span>,<span class="number">1.45938</span>,<span class="number">1.72544</span>,<span class="number">1.7293</span>,<span class="number">1.76786</span>]</span><br><span class="line">y4 = [<span class="number">9.33593</span>,<span class="number">9.3378</span>,<span class="number">9.33955</span>]</span><br><span class="line">y5 = [<span class="number">4.17834</span>,<span class="number">4.11902</span>,<span class="number">4.11519</span>,<span class="number">4.11813</span>,<span class="number">4.11791</span>]</span><br><span class="line">y6 = [<span class="number">-0.09993</span>,<span class="number">-0.14572</span>,<span class="number">-0.1498</span>,<span class="number">-0.14282</span>,<span class="number">-0.14325</span>]</span><br><span class="line">y7 = [<span class="number">0.36766</span>,<span class="number">0.22478</span>,<span class="number">0.36611</span>,<span class="number">1.94956</span>,<span class="number">1.96229</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(x1,y1,c=<span class="string">'#32CD32'</span>,ls = <span class="string">''</span>,marker=<span class="string">'o'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;Mg_v&#125;$ in pure Mg'</span>)</span><br><span class="line">plt.plot(x1,y2,c=<span class="string">'b'</span>,ls = <span class="string">''</span>,marker=<span class="string">'o'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;Mg_v&#125;$ in $\mathregular&#123;MgF_2&#125;$'</span>)</span><br><span class="line">plt.plot(x1,y3,c=<span class="string">'b'</span>,ls = <span class="string">''</span>,marker=<span class="string">'^'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;F_v&#125;$ in $\mathregular&#123;MgF_2&#125;$'</span>)</span><br><span class="line">plt.plot(x,y4,c=<span class="string">'r'</span>,ls = <span class="string">''</span>,marker=<span class="string">'o'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;Mg_v&#125;$ in $\mathregular&#123;Mg(OH)_2&#125;$'</span>)</span><br><span class="line">plt.plot(x1,y6,c=<span class="string">'r'</span>,ls = <span class="string">''</span>,marker=<span class="string">'v'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;O_v&#125;$ in $\mathregular&#123;Mg(OH)_2&#125;$'</span>)</span><br><span class="line">plt.plot(x1,y7,c=<span class="string">'r'</span>,ls = <span class="string">''</span>,marker=<span class="string">'s'</span>,mew=mew, mec=<span class="string">'black'</span>,lw=ld,ms=ms,label=<span class="string">'$\mathregular&#123;OH_v&#125;$ in $\mathregular&#123;Mg(OH)_2&#125;$'</span>)</span><br><span class="line"><span class="comment">#############Plot input region end###############</span></span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">'upper right'</span>,bbox_to_anchor=(<span class="number">0.99</span>,<span class="number">0.8</span>), prop=legend_font,edgecolor=<span class="string">'black'</span>)</span><br><span class="line"><span class="comment"># plt.grid()</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.savefig(name+<span class="string">'.pdf'</span>,dpi = <span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>





<p><img src="/2020/06/16/SCI%E4%BD%9C%E5%9B%BE%E6%A8%A1%E7%89%88/fig2_vfe.png" alt></p>
]]></content>
      <tags>
        <tag>常用脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>常用网站记录</title>
    <url>/2020/06/12/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一些日常使用的网站不迷路……</p>
<a id="more"></a>

<h4 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h4><p><a href="https://github.com/getlantern/download" target="_blank" rel="noopener">蓝灯</a></p>
<h4 id="Pt网站"><a href="#Pt网站" class="headerlink" title="Pt网站"></a>Pt网站</h4><p><a href>蒲公英</a></p>
<p>六维</p>
<p>大工pt</p>
]]></content>
      <tags>
        <tag>码农的基本素养</tag>
      </tags>
  </entry>
  <entry>
    <title>Bader电荷计算</title>
    <url>/2020/06/11/Bader%E7%94%B5%E8%8D%B7%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="http://theory.cm.utexas.edu/henkelman/code/bader/" target="_blank" rel="noopener">HenkelmanGroup</a></p>
<p><a href="https://www.bigbrosci.com/2011/12/23/A07/" target="_blank" rel="noopener">大师兄科研网</a></p>
<h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><p>优化结构$\rightarrow$Bader静态计算</p>
<h4 id="Bader电荷分析的计算部分"><a href="#Bader电荷分析的计算部分" class="headerlink" title="Bader电荷分析的计算部分"></a>Bader电荷分析的计算部分</h4><p>1）将优化结构得到的CONTCAR改名为POSCAR</p>
<p>2）更改参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要更改的参数</span></span><br><span class="line">IBRION = -1</span><br><span class="line">NSW = 0</span><br><span class="line">LCHARG = True <span class="comment">#确定这个参数不是False否则无法写出CHGCAR</span></span><br><span class="line"><span class="comment"># 需要加的参数</span></span><br><span class="line">LAECHG = .TRUE.</span><br><span class="line">LCHARG = .TRUE.</span><br></pre></td></tr></table></figure>

<p>3) 计算后运行命令查看文件”ACF.dat”的第五列（CHARGE列）</p>
<p><code>chgsum.pl AECCAR0 AECCAR2; bader CHGCAR -ref CHGCAR_sum; cat ACF.dat</code></p>
]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>python程序的控制</title>
    <url>/2020/06/05/python%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>本文中包括python语法中单分支结构，二分支结构，二分支结构紧凑形，多分支结构和异常捕获</p>
<a id="more"></a>

<h4 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = eval(input(<span class="string">'请输入猜测的数字：'</span>))</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">99</span>:</span><br><span class="line">  print(<span class="string">'猜对了'</span>)</span><br><span class="line">print(<span class="string">'猜错了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>请输入猜测的数字： <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>猜错了</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong>自己以前总是多写带else的语句，其实不需要，单分支就可以</p>
<h4 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h4><p>以上单分支例子也可改写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = eval(input(<span class="string">'请输入猜测的数字：'</span>))</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">99</span>:</span><br><span class="line">  print(<span class="string">'猜对了'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'猜错了'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="二分支条件的紧凑型（只支持表达式，不支持赋值）"><a href="#二分支条件的紧凑型（只支持表达式，不支持赋值）" class="headerlink" title="二分支条件的紧凑型（只支持表达式，不支持赋值）"></a>二分支条件的紧凑型（只支持表达式，不支持赋值）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = eval(input(<span class="string">'请输入猜测的数字：'</span>))</span><br><span class="line">print(<span class="string">'猜对了'</span>) <span class="keyword">if</span> a == <span class="number">99</span> <span class="keyword">else</span> print(<span class="string">'猜错了'</span>)<span class="comment">#可以理解成中间是判断的条件，条件为真走左边，假走右边</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>请输入猜测的数字： <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>猜对了</span><br></pre></td></tr></table></figure>

<h4 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">63</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    score = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    score = <span class="string">'B'</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    score = <span class="string">'C'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    score = <span class="string">'D'</span></span><br><span class="line">print(<span class="string">'成绩等级为：&#123;&#125;'</span>.format(score))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>成绩等级为：D</span><br></pre></td></tr></table></figure>

<h4 id="异常捕获（try-except）"><a href="#异常捕获（try-except）" class="headerlink" title="异常捕获（try-except）"></a>异常捕获（try-except）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当try后面的语句有问题的时候才会实现except</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  num = eval(input(<span class="string">'请输入一个整数：'</span>))</span><br><span class="line">  print(num**<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">'输入的不是整数'</span>)</span><br></pre></td></tr></table></figure>

<p>高级用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  &lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  &lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  &lt;语句块<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  &lt;语句块<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>

<p>先执行语句块1，出错了执行语句块2，不出错执行语句块3，最后一定会执行语句块4。</p>
]]></content>
      <tags>
        <tag>Python基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>有那些好的科研习惯？-From知乎</title>
    <url>/2020/05/21/%E6%9C%89%E9%82%A3%E4%BA%9B%E5%A5%BD%E7%9A%84%E7%A7%91%E7%A0%94%E4%B9%A0%E6%83%AF%EF%BC%9F-From%E7%9F%A5%E4%B9%8E/</url>
    <content><![CDATA[<h4 id="经常和导师以及办公室的伙伴讨论"><a href="#经常和导师以及办公室的伙伴讨论" class="headerlink" title="经常和导师以及办公室的伙伴讨论"></a>经常和导师以及办公室的伙伴讨论</h4><p><strong>好处</strong>：得到一些启发性的建议，确保自己的方向没有偏离，保持高效。</p>
<p>当然，每个实验室的风格不太一样。在复旦的lab，老板要求我们每周六晚上10:00之前给他发邮件，汇报这一周的工作进展。这种方式有利有弊，有利的在于，会推动我们定期总结；弊端在于，我们总是想着，等到周六再汇报，那么中间积攒一些数据再跟老板讨论，会显得自己工作量比较大，但其实一周讨论一次确实太少了，很多时候你做着做着方向就偏了，或者很多实验设计地并不合理，导致一周中做了很多无用功。如果经常跟导师讨论，会确保自己得到更多的指点，也会学到更多的学术思维，避免自己做无用功。</p>
<p>USC那边的实验室风格就很不一样。工作日每天老板都在lab，随时可以找他讨论，哪怕一个再小的结果，然后一起讨论下一步的实验方案。这种方式就比较高效，老板每天都知道学生在做什么，学生每天也能得到老板的指导和讨论。当然，你也可以选择自己思考，自己设计实验方案，这个完全不矛盾，导师在办公室，只是确保你能找到他，跟他讨论。去不去，去几次根据自己的需要调整。</p>
<p>但是，讨论真的太重要了，无论是跟导师还是跟实验室的同伴。</p>
<p>作者：xupenggoing<br>链接：<a href="https://www.zhihu.com/question/394796969/answer/1228109975" target="_blank" rel="noopener">https://www.zhihu.com/question/394796969/answer/1228109975</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="规律的摆放实验器材及整洁的办公环境"><a href="#规律的摆放实验器材及整洁的办公环境" class="headerlink" title="规律的摆放实验器材及整洁的办公环境"></a>规律的摆放实验器材及整洁的办公环境</h4><p>省去每天找数据的时间，提高效率和心情。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>大师兄科研网站学习心得</title>
    <url>/2020/05/20/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><ol>
<li>Density functional theory：A practical introduction, by David Sholl </li>
<li>Vasp pdf 官方手册 </li>
<li>Vasp官方论坛</li>
<li>Vs-code 文本编辑</li>
<li>Material studio</li>
<li>P4-vasp</li>
<li>Vesta(原子结构可视化软件)</li>
<li>ATOM(文本编辑软件)</li>
<li>notepad++(文本编辑软件)</li>
<li>Putty(Win下远程登录软件)</li>
</ol>
<h4 id="输入文件简介"><a href="#输入文件简介" class="headerlink" title="输入文件简介"></a>输入文件简介</h4><p><strong>INCAR：</strong>告诉VASP算什么，怎么算</p>
<p>金属ISMEAR=1，分子，半导体和绝缘体ISMEAR=0。在DOS能带计算中， 使用ISMEAR = -5 用于获取精确的信息。 SIGMA一般取0.10 或者采用默认值 0.20 即可。 当ISMEAR=-5时，SIGMA的值可以忽略。分子原子体系，SIGMA=0.01。SIGMA的测试标准是：<code>grep &#39;entropy T&#39; OUTCAR</code>/体系原子数目 &lt; 0.001即可。</p>
<p><strong>POSCAR：</strong>各个原子的位置信息</p>
<p><strong>KPOINTS：</strong>包含计算的K点信息==（不理解什么是K点信息）==</p>
<p>Monkhorst-Pack Grid(原始网格)。gamma centered Monkhorst-Pack Grid (高等级的)</p>
<p>两者的区别是 M 在 G的基础上在三个方向上平移了1/(2N)个单位。<strong>计算时</strong>：(1)对于原子或者分子的计算，K点取一个gamma点就够了。(2)永远用Gamma centered就可以了。</p>
<p><strong>POTCAR：</strong>对应的是计算过程中每个原子的平面波基组，描述原子中原子核和电子的相关信息。 ==（什么是平面波基组？这个问题我一直不太了解）==</p>
<p>POTCAR要和POSCAR保持一致，负责计算会出错。</p>
<p><code>grep TIT POTCAR</code> 查看POTCAR中的元素</p>
<p><code>grep ENMAX POTCAR</code> 查看POTCAR的Cut-off 能量</p>
<h4 id="一些常见的linux操作"><a href="#一些常见的linux操作" class="headerlink" title="一些常见的linux操作"></a>一些常见的linux操作</h4><p><code>man cat</code>  or <code>cat -help</code> 查看cat命令帮助</p>
<p><strong>cat:</strong> 文件名前加n会显示行数<code>cat -n INCAR</code></p>
<p><strong>more:</strong>和cat一样用来查看文件</p>
<p><strong>less:</strong> 运行后，敲v是编辑命令，敲q是离开命令</p>
<p><strong>echo:</strong>相当于python的打印命令</p>
<p>linux下的单引号会不识别变量，只有双引号识别变量</p>
<p><strong>seq:</strong> 类似range()或者np.arange()，用来生成一串数字</p>
<p>seq 1 2 10，会生成1，3，5，7，9</p>
<p><strong>tree:</strong>生成当前目录结构，<code>tree -d</code>只显示文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立0.01-0.09九个文件夹</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..9&#125;; <span class="keyword">do</span> mkdir 0.0<span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="comment">#INCAR 内容</span></span><br><span class="line">     1	SYSTEM = O_atom</span><br><span class="line">     2	ISMEAR = 0</span><br><span class="line">     3	SIGMA = 0.01</span><br><span class="line"><span class="comment">#分别替换0.01-0.09九个文件夹中的SIGMA值为0.01-0.09</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..9&#125;;<span class="keyword">do</span> sed -i <span class="string">"3s/0.01/0.0<span class="variable">$i</span>/g"</span> 0.0<span class="variable">$i</span>/INCAR ;<span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..9&#125;;<span class="keyword">do</span> sed -i <span class="string">"3,5s/0.01/0.0<span class="variable">$i</span>/g"</span> 0.0<span class="variable">$i</span>/INCAR;<span class="keyword">done</span>(选择3-5行)</span><br></pre></td></tr></table></figure>

<h4 id="输出文件-OSZICAR详细解读-E0"><a href="#输出文件-OSZICAR详细解读-E0" class="headerlink" title="输出文件-OSZICAR详细解读(E0)"></a>输出文件-OSZICAR详细解读(E0)</h4><p>判断计算是否收敛：<code>tail OUTCAR</code>看是否有user time那些参数</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/oszicar.png" alt="oszicar"></p>
<p>（由于是单个O原子体系，所以没有进行结构优化，只有一个离子步）</p>
<p>N：表电子步的迭代步数，本例中里面有7个电子步；</p>
<p>E：当前电子步的体系能量； </p>
<p>dE：该步和上一步两个离子步体系能量的差值； 在单点（静态）计算中，等于entropy<em>SIGMA的值。SIGMA值来自于INCAR，entropy,对应entropy T\</em>S这个值，可以在OUTCAR中获得。</p>
<p><code>grep &#39;entropy T&#39; OUTCAR|tail -n -1</code>|会把前面的结果传到后面</p>
<p>d eps: the change in the bandstructure energy, 本征值的变化 </p>
<p>nag: the number of evaluations of theHamiltonian acting onto a wavefunction；波函数的优化次数 </p>
<p>rms: the norm of the residuum of the trialwavefunctions (i.e. their approximate error) </p>
<p>DAV/RMM/CG：blocked Davidson iteration scheme的缩写，一个电子自洽算法的缩写，今后的计算中还有RMM (residual minimization scheme) 和 CG （conjugate-gradientalgorithm）等，这些参数有INCAR中的ALGO决定。（ALGO = FAST is a very reasonable compromise, and should be specified for system with more than 10-20 atoms）。</p>
<p><strong>==后面的几个参数一知半解==</strong></p>
<p>F:体系的总能量=<code>grep &#39;free energy TOTEN&#39;  OUTCAR</code></p>
<p>E0:后能量对应OUTCAR中 energy(sigma-&gt;0)后面的能量</p>
<p>energy without entropy=free energy TOTEN 后面的能量减去 Entropy T*S 后面的能量</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/outcar.png" alt="outcar"></p>
<h4 id="输出文件OUTCAR的基本内容"><a href="#输出文件OUTCAR的基本内容" class="headerlink" title="输出文件OUTCAR的基本内容"></a>输出文件OUTCAR的基本内容</h4><p>固体物理中，费米能级对应最高电子占据的轨道能量，就是HOMO。</p>
<h4 id="O原子能量的正确计算"><a href="#O原子能量的正确计算" class="headerlink" title="O原子能量的正确计算"></a>O原子能量的正确计算</h4><p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/o_e_align.png" alt="o_e_align"></p>
<p>O本来的电子排布，有两个单电子，所以O原子是有磁性的，要考虑自旋（ISPIN=2）</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/e_occupy.png" alt="e_occupy"></p>
<p>(从OUTCAR中得到)</p>
<p>Band 1中有两个电子，对应2s,但是Band2-4上带有1.33个电子，对应2p4，这里的电子占据不正确，再INCAR中加入<code>ISPIN=2</code>后，计算得到：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/WX20200524-170711@2x.png" alt="WX20200524-170711@2x"></p>
<p>电子步减少，磁（右下角mag）=0，这明显与O的电子排布不相符。查看OUTCAR中电子排布：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/image-20200524170856133.png" alt="image-20200524170856133"></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/_posts/%E5%A4%A7%E5%B8%88%E5%85%84%E7%A7%91%E7%A0%94%E7%BD%91%E7%AB%99%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/image-20200524170923573.png" alt="image-20200524170923573"></p>
<p>发现电子排布被分为spin cpmpoment1和spin component2.O原子的正确排布应该有四个向上的电子和两个向下的电子。但现在向下和向上的电子数相等，明显不对。<strong>==此时通过更改POSCAR格子的对称性来修改尝试。==</strong></p>
<p>ISYM参数为设置</p>
]]></content>
      <categories>
        <category>VASP</category>
      </categories>
  </entry>
  <entry>
    <title>精简生活</title>
    <url>/2020/05/20/%E7%B2%BE%E7%AE%80%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h4 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h4><p>每天只完成最核心的一件任务</p>
<h4 id="上网篇"><a href="#上网篇" class="headerlink" title="上网篇"></a>上网篇</h4><p>降低购物软件使用的次数，无论多便宜，多精致的东西，没有需求就不买。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Work harder, Play harder</title>
    <url>/2020/05/15/Work%20harder,%20Play%20harder----MIT%E5%AD%A6%E7%94%9F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h4 id="六天生存，一天生活"><a href="#六天生存，一天生活" class="headerlink" title="六天生存，一天生活"></a><strong>六天生存，一天生活</strong></h4><p>自己总想着用周六周日来处理一下周内没干完的事情，于是想玩又玩不尽兴，在周末做事又觉得憋屈，效率极其低下。<a id="more"></a>有的人真的很忙，觉得一周七天都不够用，怎么能用一天来纯玩。这里的核心是，一周六天处理不完的事情，一周只有七天也处理不完，就当做一周就只有六天，干不完就只能到下一周。说一周七天必须连轴转，如果不是临时增加的任务的话，大多都是周内效率不高的借口。</p>
<p>==<strong>周日是存粹的休息，但不要使用电子产品</strong>==</p>
<h4 id="精力管理，充足睡眠"><a href="#精力管理，充足睡眠" class="headerlink" title="精力管理，充足睡眠"></a><strong>精力管理，充足睡眠</strong></h4><p>接下来是每日的学习框架，简单来说就是：七个半小时睡眠 + 上午做主要工作 + 下午做次要工作 + 晚上不工作。这个框架是从看完《睡眠革命》和《精力管理》后得出来的，核心就是效率，而不堆砌时间。我的原则是哪怕学习再紧张，也要保持充足的睡眠。早上效率最高，我就会开始深度工作或学习，这一点在下一段会讲到。到下午时，基本上我就能发现自己的困倦，所以会做一些浮浅工作，回回邮件，整理材料之类的，都是花时间但不用什么精力的事情。我也试过吃完晚饭后学习，但无奈效率太低，直接放弃，这些时间就变成了社交、看书或者看剧的时间。</p>
<p><strong>==自己早上的工作效率是最高的==</strong></p>
<h4 id="深度工作，彻底关机"><a href="#深度工作，彻底关机" class="headerlink" title="深度工作，彻底关机"></a>深度工作，彻底关机</h4><p>这里主要是上午的安排，看完《深度工作》后有了很多优化。在上午，我的精力状态是一天的巅峰，从十点开始，我会 <strong>完全关掉手机</strong>，以一小时为周期，45 分钟学习 + 15 分钟休息。早上全神贯注三个周期后到下午 1 点。有课上课，没课的话，我在这里做的基本都是需要绝对集中注意力的事情，比如学习核心概念和做最难完成的作业。</p>
<p>我的小习惯是用 Apple Watch 设置一个 45 分钟的倒计时，然后开始专注，45 分钟后手腕的震动会自动提醒我休息，在专注的时间内我也不用考虑时间的问题，因为我知道有一个结束的节点。这里的核心是在 15 分钟的休息时间内也绝对不要打开手机，我通常会用 Apple Watch 做一次 3 分钟的深呼吸，然后在图书馆里随便走走，上个厕所，拼个拼图，饿了就吃点什么东西。</p>
<p><strong>==做冥想，上午学习的时候把手机关掉==</strong></p>
<h4 id="快速运行，拒绝拖延"><a href="#快速运行，拒绝拖延" class="headerlink" title="快速运行，拒绝拖延"></a>快速运行，拒绝拖延</h4><p>在 MIT 深刻认识到的就是做多数事都要快速运行，拖这么一小下基本上就是拖几天，最基本的例子就是发邮件。之前我发邮件，每个词都要斟酌半天，生怕出个语法错误。说正事之前还要来一段中国式的客套，最后的客套词 Best wishes 或者 Sincerely yours 还要变着花样来，导致每次写一封都要很长时间。到了美国之后我才发现，美国人都很讲实用，MIT 斯隆商学院的教授给我回的短邮件大概都下面长这样，事件说清楚就完了。</p>
<p><strong>==每次想拖延的时候直接开始工作就好了==</strong></p>
<h4 id="少吃午饭，少食多餐"><a href="#少吃午饭，少食多餐" class="headerlink" title="少吃午饭，少食多餐"></a>少吃午饭，少食多餐</h4><p>关于午饭，我就一点认识，少吃精制碳水。「饭困」绝对是下午工作的大敌，表现基本是中午吃了大碗白米饭或者一大碗面，哪怕中午睡过午觉，下午也昏昏欲睡。这是因为亚洲食物普遍含精制碳水较多，导致血糖水平陡增，大脑会释放出激素，结果就是让人困倦。这点在 Minja 在关于 <a href="http://link.zhihu.com/?target=https%3A//sspai.com/post/45538">代餐</a> 的文章里也提到过。</p>
<p>作为陕西人的我深有体会，中午一大碗扯面过后，吃的是很舒服，下午基本上就瘫痪了。所以在美国我中午一般就是一个三明治，下午会喝杯咖啡补充咖啡因。有时候也会少食多餐，11 点吃一个蛋白棒，1 点吃个酸奶之类的，这样下午上课也不会很困。中午还是要小憩一会儿的，回宿舍太麻烦，就趴图书馆听着歌睡 20 分钟，下午就会精神满满了。</p>
<h4 id="精简生活，少就是多"><a href="#精简生活，少就是多" class="headerlink" title="精简生活，少就是多"></a>精简生活，少就是多</h4><p>面对着信息爆炸的社会，我们每天都要面对无穷无尽的消息。微博热搜，qq群，微信消息，朋友圈，各种小视频软件……很多时候我们的经历都被分散到好多方面。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>老板的这个饼画了十年(教父Kim)</title>
    <url>/2020/04/29/%E8%80%81%E6%9D%BF%E7%9A%84%E8%BF%99%E4%B8%AA%E9%A5%BC%E7%94%BB%E4%BA%86%E5%8D%81%E5%B9%B4-%E6%95%99%E7%88%B6Kim/</url>
    <content><![CDATA[<p>接着上一篇继续讲我在国外读博士期间的故事。<a id="more"></a></p>
<p>我博士入学以后又过了不久，一个师兄也入学了。虽然比我入学晚一些但是年龄比我大，所以仍然尊称为师兄。师兄也是中国人，他来了以后，在这个学校的这台国宝级设备上工作的博士生就成了我和师兄两个人。我们俩suppose是要在这台仪器上完成各自的博士论文。</p>
<p>作为两个小县城学霸，我和师兄不仅在做实验时候要互相配合，也成了生活上很好的朋友。刚出国的两个中国穷留学生，在举目无亲的异国他乡，相依为命，报团取暖，在生活上互相帮助，一起租房一起做饭一起八卦，也在实验室里为了理想一起拼搏。</p>
<p>随着我们的一些初期的实验结果陆续出来，大老板逐渐给我们指了几个课题方向，让我们来选，换句话说，画了一个“大饼”，一个“小饼”</p>
<p>大饼：课题A是一个非常依赖设备和实验数据的课题，需要自己做大量的实验，来覆盖样品的所有情况，数据点要多到覆盖一整个二维参数空间，并且画出几个不同regime的边界，并提出合理的理论解释。该课题的目标期刊是Nature。</p>
<p>小饼：课题B更偏重于理论建模，虽然也需要一些数据，但是需要自己做的不多，很多数据可以引用国际上其他的组已经发表的实验结果。很显然，既然我们是理论建模，不仅要能解释自己的实验数据，也要解释所有其他人的实验数据。该课题的目标期刊是Nano Letter或者PRL</p>
<p>有些有经验的读者似乎可以看出来我们这个领域有一个什么特点。那就是：</p>
<p>除了老板以外，<strong>设备比人重要。</strong> </p>
<p>纵观全球的n个搞这个领域的实验室，只要你能搭起一台这种级别的设备，你就很容易出结果。搭设备可能要搭2年，出结果可能就是一宿。设备门槛很大，只要搭起来，就可以一直产出。类似的例子可以参考欧洲的大型强子对撞机LHC，还有测量引力波的全套实验设备，都是花数年耗巨资搭建实验设备，把所有实验条件都搭好以后，出结果可能就是一天、一周、一个月。</p>
<p>所以会看到世界上各个研究小组，只要出了实验结果，发二区文章很容易，几乎就可以像灌水一样发，一两个月一篇没问题。但是，如果要一区，像Nature、Science、Nano Letters、PRL、OL之类的，则需要过硬的理论模型和对该领域足够重大的贡献。所以这个领域会在各种二区期刊上有大量的文章报道实验数据，但是缺乏好的理论模型解释，一区的文章并不多。</p>
<p>当时的大老板说，课题A是可以发Nature的，而课题B只能发Nano Letter或者PRL。平时我们开例会的时候，大小老板也一直都表现了对课题A的高度重视，而对于多篇Nature Science在手的大老板，显然对课题B兴趣一般，感觉只是顺便做一做的。</p>
<p>当时的我，奋斗逼思想还是挺强的，一开始也是很想争取这个“能发Nature”的课题的。但后来经过一段时间的思考，选择了课题B。为什么呢</p>
<p>首先我的特点是数学和编程好，师兄的特点是实验技巧好，耐心细致。顺应着我们俩的这个人设，自然而然的我就应该选择课题B，师兄选择课题A，我选择小饼，师兄选择大饼。</p>
<p>同时我也考虑到也要为自己留条后路。虽然我当时还没有决定要转金融，如果我选了课题A，意味着博士这几年都要一直泡在实验室里，基本没什么理论计算的工作。这样的话时间长了可能只会按仪器设备的那几个按钮，自己的数学功底和编程功底会退化，最终变成和传说中的生物千老一样，只知道种花养鱼和按设备的按钮。这样到时候可能想转也转不了了。更何况，就算是我把实验数据做齐了，就一定能发Nature吗，最后不还是需要做理论吗？万一博士四年出来的数据给出了阴性的结果，竹篮打水一场空怎么办？所以说，课题A是一个高风险高收益的选项。</p>
<p>而课题B，做理论计算周期可就快了，几台电脑，再加上学校的超级计算机，并行着跑，暴力计算，可能一天就出n组结果，而做实验则是几周出一组数据。再说，领域内其他人的数据已经都发表了，既然数据都已经在那里，各种原子级的显微图像都摆在那里了，那么明显的pattern，说明肯定是有物理规律在里面的，出现“阴性结果”的概率很小。而我成天用程序暴力计算，效率那么高，出成果的概率应该还是很大的，虽然发不了Nature，但是比较稳。</p>
<p>经过综合考虑，我选择课题B，我只要能发个PRL或者Nano Letter就满足了，而发Nature的机会，就不和师兄争了，让师兄去圆梦。</p>
<p>后面的日子，我就不做实验了，每天n台电脑一起跑计算，偏微分方程，有限元分析，蒙特卡罗，各种撸模型。师兄则是数年如一日的泡在实验室里。</p>
<p>后来果然如我所料，我的工作在博士快毕业的时候有了突破性进展。而一直保持着的数学和编程功底也没拉下，金融的面试也一直在准备，很快拿到了金融的offer，也通过n篇其他的二区文章毕业了。只是毕业时候这篇大文章还没做完，这个风险也是一直担心的，它果然发生了。如果当时拿着几篇二区的文章找博士后的话，很难找到理想的下家，极有可能短暂失业，失去收入来源，签证也会受到影响。幸亏我早有准备，用金融的offer来对冲掉了这个风险。</p>
<p>尽管我转了金融，在搞金融的第一年里，我仍然通过邮件与大老板保持联系，坚持在下班时间，最终把那篇一区文章做完投了出去。在对冲基金上了快一年班的时候，那篇文章终于发表了。只是，那个时候我已经不需要它了。只是后来在找工作的简历上，我仍然会自豪的把那篇文章写在简历上，尽管用人单位可能并不知道那是什么东西。</p>
<p>大老板画的这个小饼，最终被我有惊无险的接住吃掉了，只是我已经不需要他了。</p>
<p>而师兄，就没那么幸运。</p>
<p>我担心的事情果然发生了，这篇工作，师兄在博士四年一直没有什么突破性进展。后来师兄也是通过几篇二区的文章毕业了，但是在我们领域找博后比较困难。当然，师兄也不是吃素的，他自己一直和学校其他的院系保持着联系，最后找了一个其他方向的博后，后来还申请到了一些青年学术人才的经费，还开始从中国招学生了。尽管如此，他一直和大老板保持着联系，一直坚持着继续那篇Nature的工作。</p>
<p>后来的日子，我做着金融；师兄做着博后，带着学生，在另一个领域打开了局面，做上了道。我们各自为了各自的理想拼搏，一开始还经常出来吃个饭。随着时间的推移，联系也越来越少了。</p>
<p>时光荏苒，斗转星移。在博士毕业后的第五个年头，我们聚了一次。那次聚会我们已经都成家了，带着家属，聚会由两个人变成四个人。那时候距离我们开题已经8年了，那篇Nature还没有头绪。提到这个Nature，师兄一改往日儒雅沉稳的气质，音调高了八度像打了鸡血一样哈哈大笑一声，嘴里喷着饭粒，和我高声吐槽，“<strong>我靠，xxx(大老板名字)太鸡贼了！太坑了</strong>”。其实我不知道后面他们发生了什么，但是<strong>想到七八年前师兄每次和我谈起这个课题的时候那发亮的眼神，想到我们那时候对大老板的敬畏和崇拜，和现在这个喷饭吐槽的场景，真是鲜明对比</strong>。</p>
<p>再后来师兄回国了，和小老板一样，也是进入到了一个不错的大学，拿到了帽子和经费，事业蒸蒸日上。而后面他的这些工作，做的都是他博士后后来做的那些课题，早已和博士期间这个课题无关了。</p>
<p>就在前几天，我又怀旧的搜了一下大小老板和师兄的主页，赫然看到了最近一篇发表的文章标题，就是大老板一直画的这个大饼！哇塞！我一下子兴奋了起来，终于发表了！然后仔细一看，不是Nature，是一篇二区的文章。</p>
<p>我立刻去问师兄，师兄静静的回了一句：“嗯，发了，对我而言都没什么用了”</p>
<p>这个时候，离我们开题已经整整十年有余。大老板的这个饼，画了十年，而最终发现饼并没有那么大。</p>
<p>我那种感觉，可能就像悬了几十年的悬案被破了的感觉。据说甘肃白银那个案子被破了以后，很多当年的刑警都已经退休了头发白了，当接到电话说案子破了的时候，有的人当场老泪纵横。说实在的我当时也有点流泪的冲动。</p>
<p>回想当年这些事，大老板显然是知道课题A是高风险高回报的。这种类型的课题，其实是不适合给小县城学霸类型的博士生来做的，而是适合给位置已经稳定一些博士后、副教授来做。对于我们这种穷学生来说，那时候一旦奖学金一断，立刻失去收入来源，所以在临毕业不到2年的时候，就开始考虑如何找下家，如果科研工作没有明显进展，立刻就陷入到焦虑之中，不得不另做准备。所以后来我就开始准备了金融，师兄开始和学校里其他院系勾搭。如果我们俩家境都很优越，根本不在乎有没有生活费的话。我很有可能就不急着找金融的工作，毕业后慢慢把那篇一区文章发了，再继续找教职了。大老板出身发达国家，显然不理解中国的国情，不知道我们这些小县城学霸的苦衷。当年我问他如果奖学金到期我还没毕业怎么办，他说一般学生都是家里出钱供着继续读。我说，我家没钱。。。。</p>
<p>其实这文章并不是说大老板有什么不好，他确实是一个优秀的科学家，只是因为科研本来就是这样，读博士本来就是这样，你做的就是不确定性的工作，创造性工作，解决世界上还未被解决的问题，就是要承担这样的风险的。</p>
<p>只是对于小县城学霸来说，要充分了解这样的风险，充分考虑自己的风险承受能力，在选题上不要轻易超出自己风险承受能力，一旦感觉到风险，就要早做准备，多条腿走路，对冲风险，才能使自己的职业道路顺利发展。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>如果继续下去，我也许真的能发CNS，但是可能要绝后(教父Kim)</title>
    <url>/2020/04/29/%E5%A6%82%E6%9E%9C%E7%BB%A7%E7%BB%AD%E4%B8%8B%E5%8E%BB%EF%BC%8C%E6%88%91%E4%B9%9F%E8%AE%B8%E7%9C%9F%E7%9A%84%E8%83%BD%E5%8F%91CNS%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E8%83%BD%E8%A6%81%E7%BB%9D%E5%90%8E-%E6%95%99%E7%88%B6Kim/</url>
    <content><![CDATA[<p>本文说的都是真实经历。。。<a id="more"></a></p>
<p>当年我刚到国外开始读博士，我的大老板是一个领域内小有名气的教授，白人，有n篇CNS和20+的专业内大文章。开题过程中也和我画了很不错的饼。我们要做一个xxxx的课题，如果做成了，我们就是世界上唯一一个能解决xxx大问题的人，而我就可以发CNS，有着光明的学术前程。我还有一个小老板，是中国人，比我大十岁上下，刚跳槽过来不久，做research fellow，也是大文章在手，意气风发，锋利而又儒雅。</p>
<p>我们每周一到两次例会，大老板给我们点拨大方向并做理论模型的指导，小老板每天带我们在实验室里操作着巨款搭起来的占满了一整个屋子的仪器。这台仪器被我们这个大学像宝贝一样供起来，因为指望着我们发Nature，Science。而这并不是空想，我刚入学的时候，大老板小老板合发的一篇Science正刊刚刚被接收，几个月后就发表了。大老板又多了一篇CNS，小老板有了人生中的第一篇CNS。这无疑是对我这个新来的博士生的强烈激励。我作为唯一在这台仪器上工作的博士生，自然是雄心万丈，甚至觉得我博士阶段做的东西没准再过几十年还有机会拿个诺贝尔奖…..</p>
<p>那时候天总是很蓝，</p>
<p>日子总过得太慢</p>
<p>你总说毕业遥遥无期</p>
<p>转眼就Nature Science ….</p>
<p>但是当时有一个有意思的现象:</p>
<p>大老板50多岁的人了，早已成家多年，没有孩子。一开始我觉得老外可能思想比较先进，做一个丁克族，真时髦。这一开始并没有引起我的注意。</p>
<p>后来过了一段时间以后，我发现小老板也已经成家多年但是也没有孩子，并且声称不打算要孩子。要知道那时候小老板已经过了35岁了。这就有意思了，这真的是巧合吗？</p>
<p>随着工作越来越深入，我开始逐渐明白为了大小老板都不要孩子，因为：根本没那个条件。</p>
<p>我们做的实验并不是什么有毒有害的实验，但是我们为了发CNS，每天拼命的工作，上班和下班没有任何区别，7天24小时都在惦记着课题。而且我们的实验设备是24小时运转的，比如抽一波真空就要抽48小时。一旦跑一组实验，就要24小时惦记着，有时候需要睡在实验室里。我为实验室写了很多监控程序，一旦设备状态出现异常，就发短信到手机里，一定级别的报警则直接拨打手机。24小时里无论什么时候，只要手机一响，哪怕是正在和女朋友啪啪啪，也得马上停止，飞奔到实验室。而像周末和朋友唱k唱到一半，烧烤烤到一半被打断叫到实验室，是家常便饭。</p>
<p>为什么要这么急，因为这设备很脆弱，一旦真空腔内有东西烧了，整套设备就全完蛋，我们整个组很有可能被全部炒掉，更别提什么CNS了。</p>
<p>为了发CNS，我们一组一组的做着实验。做一组数据需要连续3-4天日夜不停。中间一旦出什么错误，就得重来。那种生活状态可想而知。如果设备闲着，则是7x24小时的惦记着理论模型，不停的写matlab算来算去。</p>
<p>而且我们很多实验操作是两个人配合一起做。所以即便我没有实验做，如果师兄在做实验跑数据，我也得7x24小时随叫随到。</p>
<p>这种状态，大老板是从年轻一直做到50多岁，来我们学校做了大教授之后才终于不用自己亲自做实验了，因为实验的工作有我的小老板来接班。小老板正值当年，也和我这个博士生一起，7x24泡在实验室里，每天生活在焦虑中。</p>
<p>焦虑是什么概念？伍子胥被军队追杀，面临生命危险的时候，会一夜白头。我们没有那么严重，但是我们焦虑的是实验室被毁，丢工作，发不了文章，以后找不到教职。焦虑得是博士几年做不出东西。科研是做前人从来没有做过的东西，做不出来就是做不出来，再拼命都没用。</p>
<p>这种工作强度，不只是体力，更重要的是累心，不知道读者能否体会到。就这个状态，怎么生孩子，怎么养孩子，怎么顾家？7x24的活在这种强度的焦虑中。<strong>我非常怀疑当时的精子质量是否达标</strong>，不过那时候我也没测过。</p>
<p>所以大老板，小老板，都没有功夫没有精力要孩子。后来毕业了很多年，小老板也一直没有要孩子。不知道现在怎么样了。</p>
<p>想知道你这个专业的前途，不妨先看看你的老板和师兄师姐。</p>
<p>如果继续在这个领域里干下去，<strong>他们的今天，就是我的明天。</strong></p>
<p><strong>如果继续下去，我也许真的能发CNS，但是，这是TM的要绝后啊！</strong></p>
<p><strong>所以说天坑专业有时候不只是没钱，还要绝后！</strong></p>
<p>不孝有三，无后为大。这也是促使我转金融的一大因素。但不是唯一因素，其他因素，后面的文章慢慢讲。</p>
<p>于是我就开始准备逃离，开始准备金融的面试。</p>
<p>快毕业的时候，我开始频繁的面试，很快开始有了offer。我拿到的第一个offer是一家知名美国对冲基金在中国的分部，当时谈的底薪是35万人民币，年终奖另算。那时候我的小老板也在找国内的工作，某个大学给他正教授的offer。我和他提起我的offer的时候，他用一种有点复杂的语气和神态我说：“比我都多，如果是我我也去！”。   </p>
<p>小老板还问我想不想和他回国跟他一起干，我问他给多少钱。他知道我有35万的offer，说肯定给不了那么多，他去问问学校领导。后来和我说了个数字：10-30万。 我说，那意思就是10万了。  于是我们俩都呵呵了。</p>
<p>后来我没有接受国内那个offer，因为拿到了更满意的，进了当地的一家对冲基金。小老板接受了国内的offer，回国做了正教授。</p>
<p>后来小老板回国后，因为引进了国内没有的方向和技术，很快打开了局面，事业做的风生水起，不仅学术道路硕果累累，同时也和工业界合作，引入了资本介入，通过横向项目实现了年入百万+。同时又是学术带头人，实验室主任，领域内大佬，名利双收。回想当年一起在地球另一端某个实验室里一起拼搏过的日日夜夜，衷心为他高兴，这是他应得的。搞金融多年以后，我还经常到到google scholar上看看我和他一起发表的文章怀旧一下，看看引用了多少次了。</p>
<p>但是小老板这条路并不具有代表性和参考性，除了他的过硬的个人实力外，也是因为在一个合适的timing回国进入一个空白领域，利用国内外的时间差、信息差、资源差，进行降维打击。这就像 <a href="http://www.zhihu.com/people/c3239475688a09f3252cc320cc214ce4" target="_blank" rel="noopener">@弗兰克扬</a> 所说的电梯效应，他坐对了“电梯”。而他同时在适当的时机曾参与横向项目、吸引资本介入，实现收入上的飞跃，这就是他的另一方面个人能力的体现了，他又坐对了另外一部“电梯”。在这第二点上，不在于他多能发CNS，而在于他选择“电梯”的能力。这可以说是另外一个在天坑专业杀出一条血路的例子</p>
<p>而我，进了对冲基金以后，生活完全变了样子。收入丰厚，按时下班，朝九晚六，带薪年假。并且很快结婚买房。</p>
<p>在过了几年冲浪，潜水、跳伞、野营的日子后，我开始为了提高精子质量而健身，每周两次健身房团操，两次游泳1500米，逐渐练出了腹肌。 再后来就有了自己的孩子，很健康。</p>
<p>在我后面又来了一个中国学生，虽然比我晚，但是比我年龄大，所以还是叫师兄。师兄后来也是逃离了我们这个方向以后开始生孩子。 他现在已经三个孩子了。。。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>我是怎样有惊无险的逃脱天坑专业的(教父Kim)</title>
    <url>/2020/04/29/%E6%88%91%E6%98%AF%E6%80%8E%E6%A0%B7%E6%9C%89%E6%83%8A%E6%97%A0%E9%99%A9%E7%9A%84%E9%80%83%E8%84%B1%E5%A4%A9%E5%9D%91%E4%B8%93%E4%B8%9A%E7%9A%84-%E6%95%99%E7%88%B6Kim/</url>
    <content><![CDATA[<p>最近这几个月一直在读 <a href="http://www.zhihu.com/people/c3239475688a09f3252cc320cc214ce4" target="_blank" rel="noopener">@弗兰克扬</a>扬叔的文章，觉得此人真的是良心写手，”当代鲁迅”。<a id="more"></a>可以说是用自己亲身经历和优秀的文笔非常到位的揭示了近几十年一些领域的真相。我之所以这么挺扬叔是因为我和他年龄相仿，经历相似。他里面提到的所有的天坑我大部分都经历过，都曾经多次徘徊在天坑的边缘，离入坑只有一步之遥，但是庆幸的是几乎每一步都没有跳，或者刚跳进去马上就逃坑成功，最终进入金融领域。现早已逃脱了5千块定律，也摆脱了苦逼实验室民工的生活，也过上了标准的西方国家中产的生活。</p>
<p>现在读了扬叔的系列文章，回想当年，唏嘘不已，各种后怕。当年只要走错一步，就很难有今天的生活。当年的我，就是扬叔描述的那种典型的那种“小县城学霸”，父母阶层和见识有限，无法在人生关键阶段给予足够的指导，家里经济条件又不足以支撑在大城市立足和自费出国，更没有什么其他的人脉资源能够在就业升职上给予支持。回想当年的自己真的是两眼一抹黑，但是因为误打误撞的做了几波关键操作，在最后得以成功逃坑。这里回顾一下我自己的逃坑经历，可以供给还在挣扎着的同学们参考。有人说扬叔的文章只传播负面情绪不提供解决方案，我这里就提供一些解决方案。同时作为我的专栏的第一篇文章。</p>
<p>我读的专业是物理，没有读生化环材，而且我保送进了top2。之前看知乎讨论物理是不是天坑专业，有人说因为学物理的人数学和计算机也容易学得很好，转计算机很容易，所以不坑。其实不然，学了物理，哪怕是top2的物理系，如果没操作好，依然会是和四大天坑一样的下场。只是top2的平台好一些，大多数人能过很早就通过学长和同学口中知道一些事情的真相，然后又比较有行动力，逃坑容易一些。</p>
<p>还有一个原因是这个问题也是个幸存者偏差或者说逆向选择的问题，真相是如果数学和计算机不够好的人，根本就不会对物理产生兴趣，也大概率不会选择物理系。物理这个名字本身就让人觉得是个不赚钱的专业，不像生化环材那样有那么大的欺骗性。所以选择物理系的人一般都是真正喜欢的。这种逆向选择造成了来到了物理系的人本来就已经具备了转行的能力了，而不是物理这个专业多么的不坑。生化环材这些专业的问题是，专业的名字以及一些不良舆论本身带了一层欺骗性，会让数学和计算机没有足够好的小县城学霸误认为进入该专业以后会很容易按部就班理所当然获得高收入高社会地位，但是最后被社会现实无情的打击。 </p>
<p>下面回顾我的几波“关键操作”：</p>
<h3 id="第一波操作：大学时候在中关村打工"><a href="#第一波操作：大学时候在中关村打工" class="headerlink" title="第一波操作：大学时候在中关村打工"></a>第一波操作：大学时候在中关村打工</h3><p>我的第一波比较幸运的操作是，在读大学的时候，因为没钱，又频繁参加社团活动，想买很多昂贵的玩具，比如摄影器材，轮滑鞋，乐器等等，就频繁去中关村的互联网公司兼职打工，有小公司，也有大厂。在大厂里打工的收入一个月能有三四千，在那个年代对于一个穷学生来说已经很可观了。而自己的过硬的写代码的本领也是在那个时候练就的。多年以后在我转行量化金融领域的时候，真正起到核心作用的，不是我的专业课四大力学考了多少分，也不是发了多少篇CNS，而是实打实的写代码功底。这些写代码的经历，根本上是由于上大学时候的时候买大件玩具的物质欲望所导致的行为。这第一波操作为以后逃坑奠定了坚实的基础。</p>
<p>给逃坑者得建议：<strong>赶紧出去做兼职写代码，现在就行动！</strong></p>
<h3 id="第二波操作：天坑专业直博申请转硕成功"><a href="#第二波操作：天坑专业直博申请转硕成功" class="headerlink" title="第二波操作：天坑专业直博申请转硕成功"></a>第二波操作：天坑专业直博申请转硕成功</h3><p>我第一次差点入坑是保送研究生的时候，那个时候虽然本科毕业但是仍然一直呆在象牙塔里对社会一无所知。于是选择了一个“材料物理”工科方向，而且是直博，那时候天真的觉得这个方向是一个“实用”的专业，以后可以赚钱。但是刚刚进去了这个专业以后马上就觉得不对劲。因为那时候谈了一个恋爱，开始真正的为后面的日子做打算，发现后面的日子如果我留在北京，可能一辈子也买不起北京的房子，可能到35岁还拿不到教职，一个月就拿着两三千的博士后工资。即便熬到40岁做到教授，北大教授一个月也就6000多的工资。那种日子让我产生了极度的恐惧感，毅然打算放弃直博，转硕出国。于是研究生第一年我就朝导师写了一个转硕士的申请。要知道直博生一般是不允许转硕的，有的时候还要付违约金。还好我的导师厚道，放了我一马。<strong>现在来看要非常感谢我的厚道的硕士导师，堪比我的人生一大贵人</strong>。这是人生第一次有惊无险，差点踩坑。</p>
<h3 id="第三波操作：申请出国，去英联邦，拿到offer"><a href="#第三波操作：申请出国，去英联邦，拿到offer" class="headerlink" title="第三波操作：申请出国，去英联邦，拿到offer"></a>第三波操作：申请出国，去英联邦，拿到offer</h3><p>转硕成功之后，就开始准备GRE，托福，雅思。至于为什么考雅思，是因为如果读了3年硕士再去美国读博的话，仍然要再从头读5年，再加上普遍的延期1-2年，毕业了可能就32-33岁了。而那个时候对美国的天坑专业博后千老的传说已经开始有所耳闻。同时英联邦国家的博士只需要3-4年毕业，而且有些国家申请绿卡也比美国的容易，据说英国要5年，澳加要2年，而美国一般至少8年，还不一定。在拿到绿卡之前，在美国要忍气吞声甚至要牺牲收入。一听说这些经历，果断报了雅思，转战英联邦。当然，因为有top2的背景，还是比较轻松的拿了几个全奖offer，当然，专业不再是生化环材，而是继续做物理。</p>
<p>给逃坑者建议：<strong>出国</strong></p>
<h3 id="第四波操作：转战金融"><a href="#第四波操作：转战金融" class="headerlink" title="第四波操作：转战金融"></a>第四波操作：转战金融</h3><p>刚出国第一年，因为我进了一个不错的组跟了一个比较强的导师，还信誓旦旦的想要在博士期间发表个CNS，进而走上一马平川的学术道路。那时候的思路还和扬叔说的一样，只要我攻克了xx问题，就能发Nature，只要我发了Nature，就能后面去xxx做博后，只要我去了xxx做博后，以后就可以青年千人回国了。。。。等等一系列的“只要A就能B”的思路。但是随着时间的推移马上就开始觉得不对劲。因为虽然是出了国，仍然是在实验室里成了苦逼的科研民工，而且通过初步的开题报告，就已经大概了解了我们这个方向的现状，基本上做博后，全世界只有那么几个城市可以去，没得选，而且工资少的可怜。快毕业的时候我问大老板说如果跟你做博后你给我开多少钱，他说了一个少的可怜的数字。一想这少的可怜的工资，全球少的可怜的位置，还有一眼望到头的博后千老生活。我的心立马就凉了。那个时候在MitBBS上已经开始有了“北美猥琐男”的种种讨论，和几篇描述北美博后千老的辛酸生活的网络文学《老王，老刘和老张 》系列，于是下定决心，当机立断，开始努力转金融。</p>
<p>物理如果一直读下去，如果一直走学术路线，其实和生化环材的坑差不多，甚至还不如生化环材容易找教职。但是物理系一直有一个终极转行大法存在—-进华尔街。这也是我们很多当初进了此专业的人一开始没有预料到的。当自己人生某个阶段感觉到形势不妙的时候，金融立刻就成了救命稻草。于是现在毕业已经快20年了，看我的当年差不多一半多的同学都已经进入了金融业。当年我们物理系入学的时候老师和我们讲，你们这些人以后只有5%的人会继续搞物理。现在来看，果然被言中。</p>
<p>转金融的操作，首先在博士方向上，开始往理论计算方向上靠。虽然扬叔说的转所谓的什么“计算化学”和“生物统计”之类的方向并没有什么卵用。但是我这个方向还行，需要数值解偏微分方程，需要各种数学建模，这些正好是华尔街需要用的。所以我从第二年开始就不在实验室做实验了，开始纯做理论计算了。同时也在亚马逊上购买了面试习题集，开始刷量化金融面试题，当时记得把绿皮书刷了5遍，红皮书刷了3遍。最后，终于在毕业的时候顺利的拿到了当地一家对冲基金的offer。</p>
<h3 id="第五波：顺利拿到绿卡，买房，结婚"><a href="#第五波：顺利拿到绿卡，买房，结婚" class="headerlink" title="第五波：顺利拿到绿卡，买房，结婚"></a>第五波：顺利拿到绿卡，买房，结婚</h3><p>有了前面几波操作的基础，后面这波操作就是理所当然了顺理成章了。</p>
<p>比较感慨的是，当我博士毕业，踏上了金融业的岗位，刚刚开始拿到对冲基金的工资的时候，才感受到什么才是正常人的生活。原来自己以前30年的生活，一直生活在对未来的焦虑中，焦虑自己什么时候能买得起北京的房子，职业的出路在哪里，希望在哪里。因为搞科研，下班和上班是没什么区别的，要一直惦记着课题，惦记着发文章，要一直惦记着实验室里24小时里跑着的仪器，一刻不得安宁，无比的心累。而这么多的付出，这么多年的寒窗苦读，一年就拿那么点可怜的工资，还没有永久职位，永无出头之日。</p>
<p>而搞了金融的以后，每个月拿到手里的钱数比原来多了n倍，更重要的是可以准时下班，下班以后再也不用惦记着工作了，可以尽情的过业余生活，尽情的谈恋爱，旅游，运动，还有一年好几周的带薪年假。有了充足的现金流，充足的业余时间，生活变成了阳光、海滩、冲浪、camping、跳伞、演唱会、自驾游，可以正常的谈恋爱风花雪月。后面很快就是顺理成章的结婚，买房、投资理财，逐渐构建起自己的家庭portfolio，靠专业知识管理着家庭的各种现金流，包括租金、股票、期货、基金等等。 这个时候再回头看一直在实验室里的苦逼科研民工，只能呵呵了。</p>
<p>现在回顾过去十多年的逃坑经历，有几个关键的点：</p>
<p>1：不要自己骗自己，没希望就是没希望。不要拿自己读了某生化环材的博士就是国家的人才了来骗自己。<strong>国家真的拿你当人才，怎么一个月就给你那么几千块钱呢？怎么不给你北上广的房子呢？怎么不给你北京的户口呢？婚恋市场上你怎么那么被鄙视呢？凭什么你那么多年寒窗苦读，最后就拿那么点钱那么苦逼的生活？凭什么学习不如你的邻居家孩子当了基金经理年薪百万？你就配拿那点可怜的工资望着房价兴叹吗？你体验过年入百万的现金流吗？</strong>相信我，当你真的有了年入百万的现金流，你看待世界的角度会变的，会觉得你当年那些自己骗自己的理由是多么的可笑。而且赚钱多了一样不影响你当人才，你可以自己成立一个基金，专门资助那些还执迷不悟的科研民工们，让他们写proposal找你来申请经费，你来做发经费的人，这样岂不比你在实验室成天过柱子、调PID、PCR贡献更大？</p>
<p>2：感觉不对劲，要立刻果断的行动，当机立断，不要犹豫不决，不要自己骗自己。<strong>要时刻和自己说，如果不及时转行， 以后就是穷屌丝！一点希望都没有！</strong>要转计算机，就马上自学编程然后出去接活，现在就行动！</p>
<p>3: <strong>不要在国内读博士</strong>(除非你导师是杨振宁、施一公之类大佬而你又是重点培养对象)。天坑专业也不是一点红利都没有，有一点红利就是出国拿全奖容易。这一点可以作为本科或者硕士毕业时候暂时的一个红利。</p>
<p>4：全奖出国的这个红利<strong>切记不能战线拉太长</strong>。如果闷头读六七年的博士毕业以后转行无望，那就只有千老博后的命了。如果要转行去华尔街，博一就开始准备。如果苗头不对，就果断放弃读博。我同学里有好几个放弃读博回国考CFA的，现在要不就是明星分析师，要不就是大基金经理，都是年入几百万那种。要知道你在实验室过拼搏那几年的精力如果用来考个CFA三级，就有很大机会去当基金经理了。</p>
<p>5：<strong>早拿绿卡</strong>！一定要早拿绿卡，在国外生活，拿了绿卡和没拿绿卡是完全两个不同的心态，没绿卡就是个赤裸裸社会底层，n等公民，连结婚买房都费劲。而且美国又那么难拿绿卡，h1b签证又要抽签。去个容易拿绿卡的英联邦国家，英澳加，或者新加坡，香港(现在不行了),  甚至日本、瑞典、荷兰等等，也比在美国撞大运抽签h1b和忍气吞声拿着h1b被压榨强。所以，除非本科毕业就出国而且是去大城市藤校，否则的话，<strong>不要去美国！不要去美国！不要去美国！</strong>重要的话说三遍。</p>
<p>6：在国外成功拿到互联网或者金融的职位以后，在适当的时机回国，不要只订着一线城市，多看看二三线城市，有很多城市都有那种人才引进政策。这是在国外30-40岁之间的又一波红利。最近这些年我很多同学都陆续回国了。为什么回国呢，因为国内给的帽子大，待遇好，甚至直接给房子给经费，直接带团队，或者干互联网的直接拿融资。而在国外就是一个打工仔，顶着玻璃天花板升不上去。确实比国外发展好了。这显然又是一波红利</p>
<p>所以</p>
<p>珍爱生命，远离天坑专业，远离生化环材，加油吧伙计！</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>寻找对称表面脚本</title>
    <url>/2020/04/20/%E5%AF%BB%E6%89%BE%E5%AF%B9%E7%A7%B0%E8%A1%A8%E9%9D%A2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.core.surface <span class="keyword">import</span> Slab, SlabGenerator, generate_all_slabs, Structure, Lattice, ReconstructionGenerator, get_symmetrically_distinct_miller_indices</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.structure <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.adsorption <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pymatgen.ext.matproj <span class="keyword">import</span> MPRester</span><br><span class="line"><span class="keyword">from</span> pymatgen.symmetry.analyzer <span class="keyword">import</span> SpacegroupAnalyzer</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.inputs <span class="keyword">import</span> Poscar</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">mpr = MPRester(<span class="string">'Bw7HdCARiXvzEWJK'</span>)</span><br><span class="line">path = os.getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要修改</span></span><br><span class="line">mp_id = <span class="string">"mp-153"</span> </span><br><span class="line"><span class="comment"># struct = Structure.from_file("Y3Mg.vasp")</span></span><br><span class="line">struct = mpr.get_structure_by_material_id(mp_id)</span><br><span class="line">struct = SpacegroupAnalyzer(struct).get_conventional_standard_structure()</span><br><span class="line"></span><br><span class="line">formula = struct.composition.reduced_formula</span><br><span class="line">print(<span class="string">"输入的结构是:&#123;&#125;"</span>.format(formula))</span><br><span class="line"></span><br><span class="line">ls = get_symmetrically_distinct_miller_indices(struct, <span class="number">1</span>, return_hkil=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.mkdir(formula)</span></span><br><span class="line"><span class="comment"># os.chdir(formula)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">    slab = SlabGenerator(struct, miller_index=i, min_slab_size=<span class="number">25</span>,min_vacuum_size=<span class="number">15.0</span>, lll_reduce=<span class="literal">True</span>, center_slab=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> n, slabs <span class="keyword">in</span> enumerate(slab.get_slabs(bonds=<span class="literal">None</span>, ftol=<span class="number">0.1</span>, tol=<span class="number">0.1</span>, max_broken_bonds=<span class="number">0</span>, symmetrize=<span class="literal">True</span>, repair=<span class="literal">False</span>)):</span><br><span class="line">        slabs.make_supercell([[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">    <span class="comment">#     open(formula + mp_id[3:] + '-' + str(n+1) + '.vasp', 'w').write(str(Poscar(slabs)))</span></span><br><span class="line">        name = str(i).split(<span class="string">','</span>)[<span class="number">0</span>][<span class="number">1</span>]+str(i).split(<span class="string">','</span>)[<span class="number">1</span>][<span class="number">1</span>]+str(i).split(<span class="string">','</span>)[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">        open(formula+<span class="string">'_'</span>+name +<span class="string">'_'</span> + str(n+<span class="number">1</span>) + <span class="string">'.vasp'</span>, <span class="string">'w'</span>).write(str(Poscar(slabs)))</span><br><span class="line"><span class="comment"># os.chdir(path)s</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>自动计算对称表面表面能脚本</title>
    <url>/2020/04/20/%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E5%AF%B9%E7%A7%B0%E8%A1%A8%E9%9D%A2%E8%A1%A8%E9%9D%A2%E8%83%BD%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 20200422添加mp库修正原子能量</span></span><br><span class="line">eles = &#123;<span class="string">'La'</span>:<span class="number">-4.9266</span>, <span class="string">'Ce'</span>:<span class="number">-5.9343</span>, <span class="string">'Pr'</span>:<span class="number">-4.7837</span>, <span class="string">'Y'</span>:<span class="number">-6.4674</span>,</span><br><span class="line">        <span class="string">'Er'</span>:<span class="number">-4.5674</span>, <span class="string">'Li'</span>:<span class="number">-1.9080</span>, <span class="string">'Sm'</span>:<span class="number">-4.7163</span>, <span class="string">'Ni'</span>:<span class="number">-5.7783</span>,</span><br><span class="line">        <span class="string">'Cu'</span>:<span class="number">-4.0993</span>, <span class="string">'Ag'</span>:<span class="number">-2.8262</span>, <span class="string">'Sr'</span>:<span class="number">-1.6841</span>, <span class="string">'Eu'</span>:<span class="number">-10.2906</span>,</span><br><span class="line">        <span class="string">'Hg'</span>:<span class="number">-0.3016</span>, <span class="string">'Tm'</span>:<span class="number">-4.4782</span>, <span class="string">'Ho'</span>:<span class="number">-4.5781</span>, <span class="string">'Tb'</span>:<span class="number">-4.6275</span>,</span><br><span class="line">        <span class="string">'Lu'</span>:<span class="number">-4.5259</span>, <span class="string">'Dy'</span>:<span class="number">-4.5999</span>, <span class="string">'Ba'</span>:<span class="number">-1.9246</span>, <span class="string">'Nd'</span>:<span class="number">-4.7651</span>, </span><br><span class="line">        <span class="string">'Pr'</span>:<span class="number">-4.7837</span>, <span class="string">'F'</span>:<span class="number">-1.882</span>, <span class="string">'Sc'</span> : <span class="number">-6.3325</span>,<span class="string">'H'</span>:<span class="number">-3.23975</span>,</span><br><span class="line">        <span class="string">'He'</span>: <span class="number">-0.0255</span>&#125; </span><br><span class="line"></span><br><span class="line">mu_mg = <span class="number">-1.594</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ele = str(input(<span class="string">'请输入另一种元素符号(注意大小写格式):'</span>))</span><br><span class="line">index_a =eval(input(<span class="string">'请输入化学式中Mg的原子个数：'</span>))</span><br><span class="line">index_b =eval(input(<span class="string">'请输入化学式中另一种元素的原子个数：'</span>))</span><br><span class="line">formation_energy=eval(input(<span class="string">'请输入化合物每原子的生成焓：'</span>))</span><br><span class="line">mu_formula_atom=eval(input(<span class="string">'请输入化合物每原子的DFT能量：'</span>))</span><br><span class="line">print(<span class="string">'----------计算结果输出如下----------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">total_num:单胞中总共的原子个数</span></span><br><span class="line"><span class="string">mu_formula：单胞DFT修正后能量</span></span><br><span class="line"><span class="string">ratio：用来判断切好的表面中元素个数的关系，要减去多余的不符合化学计量比的原子</span></span><br><span class="line"><span class="string">mu_F：在富Mg情况下第二种元素的原子化学势</span></span><br><span class="line"><span class="string">low：假设的一个表面能初始值，1000.用于后面找到最小的表面</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">total_num =index_a+index_b</span><br><span class="line">mu_formula =mu_formula_atom*total_num</span><br><span class="line">ratio = index_b/index_a</span><br><span class="line">low = <span class="number">1000.0</span></span><br><span class="line">mu_F = eles[ele]+formation_energy*total_num/index_b</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前目录</span></span><br><span class="line">path = os.getcwd()</span><br><span class="line">dirs = os.listdir(path)</span><br><span class="line"><span class="comment">#进入到表面目录进行循环</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">    <span class="keyword">if</span> dir[<span class="number">0</span>]==<span class="string">'0'</span> <span class="keyword">or</span> dir[<span class="number">0</span>]==<span class="string">'1'</span>:</span><br><span class="line">        os.chdir(path+<span class="string">'/'</span>+dir)</span><br><span class="line">        temp_poscar = open(<span class="string">"POSCAR"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>).readlines()</span><br><span class="line">        poscar = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> temp_poscar:</span><br><span class="line">            poscar.append(i.strip())</span><br><span class="line">        oszicar = open(<span class="string">"OSZICAR"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>).readlines()</span><br><span class="line">        x=poscar[<span class="number">5</span>][<span class="number">0</span>:<span class="number">-1</span>].split(<span class="string">" "</span>)[<span class="number">0</span>]</span><br><span class="line">        y=poscar[<span class="number">5</span>][<span class="number">0</span>:<span class="number">-1</span>].split(<span class="string">" "</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment">#获取元素的系数，x是Mg</span></span><br><span class="line">        <span class="keyword">if</span> x[<span class="number">0</span>] == <span class="string">'M'</span>:</span><br><span class="line">            num_x=eval(poscar[<span class="number">6</span>].strip().split()[<span class="number">0</span>])</span><br><span class="line">            num_y=eval(poscar[<span class="number">6</span>].strip().split()[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_x=eval(poscar[<span class="number">6</span>].strip().split()[<span class="number">1</span>])</span><br><span class="line">            num_y=eval(poscar[<span class="number">6</span>].strip().split()[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#获取表面积</span></span><br><span class="line">        temp_a = list(filter(<span class="literal">None</span>, poscar[<span class="number">2</span>].split(<span class="string">" "</span>)))</span><br><span class="line">        temp_b = list(filter(<span class="literal">None</span>, poscar[<span class="number">3</span>].split(<span class="string">" "</span>)))</span><br><span class="line">        area = eval(temp_a[<span class="number">0</span>])*eval(temp_b[<span class="number">1</span>])</span><br><span class="line">        <span class="comment">#获取收敛能量，但目前无法判断结构是否是收敛</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            energy = eval(oszicar[<span class="number">-1</span>].strip().split()[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            energy = eval(oszicar[<span class="number">-1</span>].split(<span class="string">" "</span>)[<span class="number">7</span>])</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="comment">#判断系数关系</span></span><br><span class="line">        <span class="keyword">if</span> (num_y/num_x) == ratio:</span><br><span class="line">            surf = (energy - num_x/index_a*mu_formula)/<span class="number">2</span>/area</span><br><span class="line">        <span class="keyword">elif</span> (num_y/num_x) &lt; ratio:</span><br><span class="line">            <span class="keyword">while</span> (num_y/num_x) &lt; ratio:</span><br><span class="line">                n = n+<span class="number">1</span></span><br><span class="line">                num_x = num_x<span class="number">-1</span></span><br><span class="line">            surf = (energy - num_x/index_a*mu_formula - n*mu_mg)/<span class="number">2</span>/area</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> (num_y/num_x) &gt; ratio:</span><br><span class="line">                num_y = num_y<span class="number">-1</span></span><br><span class="line">                m = m+<span class="number">1</span></span><br><span class="line">            surf = (energy - num_x/index_a*mu_formula - m*mu_F)/<span class="number">2</span>/area</span><br><span class="line">        <span class="comment">#输出表面能</span></span><br><span class="line">        convert_surf = surf*<span class="number">16000</span></span><br><span class="line"><span class="comment">#         print(os.getcwd())</span></span><br><span class="line"><span class="comment">#         print(energy)</span></span><br><span class="line">        print(<span class="string">"&#123;&#125;面,&#123;:.3f&#125; mj/m2"</span>.format(os.getcwd().split(<span class="string">'/'</span>)[<span class="number">-1</span>],convert_surf))</span><br><span class="line">        <span class="keyword">if</span> low &gt; convert_surf:</span><br><span class="line">            low = convert_surf</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># -0.018</span></span><br><span class="line"><span class="comment"># -2.4328</span></span><br><span class="line">print(<span class="string">'----------计算结果为----------'</span>)</span><br><span class="line">print(<span class="string">'表面能计算结束,最稳定表面为：'</span>+str(round(low,<span class="number">3</span>)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>python3中的常用运算</title>
    <url>/2020/04/16/python%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<a id="more"></a>

<p>注意正负数要多加验证，比如-0.5取整到-1还是0？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>**<span class="number">2</span> = <span class="number">9</span> <span class="comment">#次方运算</span></span><br><span class="line"><span class="number">1</span>/<span class="number">2</span> = <span class="number">0.5</span> <span class="comment">#正常除法</span></span><br><span class="line"><span class="number">3</span>%<span class="number">5</span> = <span class="number">3</span> <span class="comment">#取余数</span></span><br><span class="line">int(<span class="number">11</span>/<span class="number">5</span>) = <span class="number">2</span> <span class="comment">#取整数部分，向0取整</span></span><br><span class="line">round(<span class="number">3.5</span>) = <span class="number">4</span> <span class="comment"># 四舍五入</span></span><br><span class="line"><span class="number">11</span>//<span class="number">3</span>=<span class="number">3</span> <span class="comment">#取整数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#涉及到负数时，用以下方式</span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line">math.ceil(<span class="number">3.25</span>)=<span class="number">4</span> <span class="comment">#向上取整</span></span><br><span class="line">math.floor() <span class="comment">#向下取整</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>energy_above_convex_hull脚本</title>
    <url>/2020/04/14/energy-above-convex-hull%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pymatgen.apps.borg.hive <span class="keyword">import</span> VaspToComputedEntryDrone</span><br><span class="line"><span class="keyword">from</span> pymatgen.apps.borg.queen <span class="keyword">import</span> BorgQueen</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Outcar</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.phase_diagram <span class="keyword">import</span> PhaseDiagram</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.phase_diagram <span class="keyword">import</span> PDPlotter</span><br><span class="line"><span class="keyword">from</span> pymatgen.entries.compatibility <span class="keyword">import</span> MaterialsProjectCompatibility</span><br><span class="line"><span class="keyword">from</span> pymatgen.ext.matproj <span class="keyword">import</span> MPRester</span><br><span class="line"></span><br><span class="line">para = [<span class="string">"is_hubbard"</span>, <span class="string">"hubbards"</span>,<span class="string">"potcar_symbols"</span>, <span class="string">"run_type"</span>,<span class="string">"structures"</span>,<span class="string">"efermi"</span>,<span class="string">"is_spin"</span>,<span class="string">"potcar_spec"</span>,<span class="string">"atomic_symbols"</span>]<span class="comment">#,"get_computed_entry"]#"potcar_spec"</span></span><br><span class="line">dat = [<span class="string">"final_energy"</span>]</span><br><span class="line">etry = VaspToComputedEntryDrone(parameters = para,data = dat)</span><br><span class="line"><span class="comment">#entry.assimilate(a)#.to_json())</span></span><br><span class="line">path = <span class="string">"/lustre/home/acct-umjzhh/umjzhh-2/zhenming/e-hull/"</span></span><br><span class="line">queen = BorgQueen(etry,rootpath=path,number_of_drones=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#queen.serial_assimilate(path)</span></span><br><span class="line">entries = queen.get_data()</span><br><span class="line"><span class="comment">#save_data = queen.save_data('entry_save.txt')</span></span><br><span class="line"><span class="comment">#entries = queen.load_data('entry_save.json')</span></span><br><span class="line"><span class="comment">#print("entries:",entries)</span></span><br><span class="line"><span class="comment">#print("enrty0:",entries[0])</span></span><br><span class="line"><span class="comment">#print("entries:",dir(entries[0]))</span></span><br><span class="line">a=MPRester(<span class="string">"mqzy3IaxSNegF941"</span>)</span><br><span class="line">compat = MaterialsProjectCompatibility()</span><br><span class="line">computed_entries = compat.process_entries(entries)</span><br><span class="line">print(<span class="string">"len_computed_entries:"</span>,len(computed_entries))</span><br><span class="line">elements = [ ]</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> computed_entries:</span><br><span class="line">    <span class="comment">#print("entry.as_dict():",entry.as_dict()[u'parameters'][u'atomic_symbols'])</span></span><br><span class="line">    <span class="comment">#print("set(entry.as_dict():",set(entry.as_dict()[u'parameters'][u'atomic_symbols']))</span></span><br><span class="line">    element = list(set(entry.as_dict()[<span class="string">u'parameters'</span>][<span class="string">u'atomic_symbols'</span>]))</span><br><span class="line">    <span class="comment">#print("list(set(entry.as_dict():)",element)</span></span><br><span class="line">    s = [ ]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(element)):</span><br><span class="line">        s.append(str(element[i]))</span><br><span class="line">    elements.append(s)<span class="comment">#json.dumps(#.get_reduced_composition_and_factor#[u'atomic_symbols']#composition.reduced_composition#.atomic_symbols</span></span><br><span class="line"><span class="comment">#print(elements)</span></span><br><span class="line">ss=[]  </span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(element)):</span><br><span class="line">        ss.append(element[i])</span><br><span class="line">ss = list(set(ss))</span><br><span class="line">mp_entries = a.get_entries_in_chemsys(ss)</span><br><span class="line">total_entries = computed_entries+mp_entries</span><br><span class="line">pd = PhaseDiagram(total_entries)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(computed_entries)):</span><br><span class="line">    decomp,e_above_hull = pd.get_decomp_and_e_above_hull(computed_entries[i])</span><br><span class="line">    print(<span class="string">"name and ebh:"</span>,(computed_entries[i].name,e_above_hull))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>简化数据-SVD奇异值分解</title>
    <url>/2020/04/08/SVD%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>奇异值分解（singular Value Decomposition），简称SVD，线性代数中矩阵分解的方法。假如有一个矩阵A，对它进行奇异值分解，可以得到三个矩阵：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/20141228153754275.png" alt="20141228153754275"></p>
<p>这三个矩阵的大小：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/20141228153852359.png" alt="20141228153852359"></p>
<p>矩阵sigma(即上图U和V中间的矩阵)除了对角元素不为0，其他元素都为0，并且对角元素是从大到小排列的，前面的元素比较大，后面的很多元素接近0。这些对角元素就是奇异值。</p>
<p>sigma中有n个奇异值，但是由于排在后面的很多接近0，所以我们可以仅保留比较大的r个奇异值：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/20141228155108176.png" alt="20141228155108176"></p>
<p>实际应用中，我们仅需保留着三个比较小的矩阵，就能表示A，不仅节省存储量，在计算的时候更是减少了计算量。SVD在信息检索（隐性语义索引）、图像压缩、推荐系统、金融等领域都有应用。</p>
<p>在<a href="https://blog.csdn.net/u012162613/article/details/42177327" target="_blank" rel="noopener">主成分分析</a>中，我是通过特征值分解的方法来实现PCA的，除了特征值分解，还可以用奇异值分解来实现PCA。特征值和奇异值二者之间是有关系的：上面我们由矩阵A获得了奇异值sigma(i)，假如方阵A*A’的特征值为lamda(i)，则：sigma(i)^2=lamda(i)。可以发现，求特征值必须要求矩阵是方阵，而求奇异值对任意矩阵都可以，因此PCA的实现其实用SVD的更多，在scikit-learn中，PCA算法其实也是通过SVD来实现的。</p>
<h3 id="python中实现SVD"><a href="#python中实现SVD" class="headerlink" title="python中实现SVD"></a>python中实现SVD</h3><p>numpy中的linalg已经实现了SVD，可以直接调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A=mat([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>U,sigma,VT=la.svd(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>U</span><br><span class="line">matrix([[<span class="number">-0.3863177</span> , <span class="number">-0.92236578</span>],</span><br><span class="line">        [<span class="number">-0.92236578</span>,  <span class="number">0.3863177</span> ]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sigma</span><br><span class="line">array([ <span class="number">9.508032</span>  ,  <span class="number">0.77286964</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>VT</span><br><span class="line">matrix([[<span class="number">-0.42866713</span>, <span class="number">-0.56630692</span>, <span class="number">-0.7039467</span> ],</span><br><span class="line">        [ <span class="number">0.80596391</span>,  <span class="number">0.11238241</span>, <span class="number">-0.58119908</span>],</span><br><span class="line">        [ <span class="number">0.40824829</span>, <span class="number">-0.81649658</span>,  <span class="number">0.40824829</span>]])</span><br></pre></td></tr></table></figure>

<p>有一点需要注意，sigma本来应该跟A矩阵的大小2*3一样，但linalg.svd()只返回了一个行向量的sigma，并且只有2个奇异值（本来应该有3个），这是因为第三个奇异值为0，舍弃掉了。之所以这样做，是因为当A是非常大的矩阵时，只返回奇异值可以节省很大的存储空间。当然，如果我们要重构A，就必须先将sigma转化为矩阵。</p>
<h3 id="Matlab实现SVD"><a href="#Matlab实现SVD" class="headerlink" title="Matlab实现SVD"></a>Matlab实现SVD</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[u,s,v] = svd(f);</span><br></pre></td></tr></table></figure>

<p>注意：Python中的SVD和matlab中的SVD中最后一个矩阵v互为转置关系</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>python sci作图模版</title>
    <url>/2020/04/08/python-sci%E4%BD%9C%E5%9B%BE%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *<span class="comment">#控制刻度线</span></span><br><span class="line"><span class="comment">#图片尺寸设置，sci图片一般为10*8，分辨率300dpi</span></span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 设置标签和图例字体</span></span><br><span class="line">label_font = &#123;<span class="string">'family'</span> : <span class="string">'Times New Roman'</span>,</span><br><span class="line"><span class="string">'weight'</span> : <span class="string">'normal'</span>,</span><br><span class="line"><span class="string">'size'</span>   : <span class="number">10</span>&#125;</span><br><span class="line">legend_font = &#123;<span class="string">'family'</span> : <span class="string">'Times New Roman'</span>,</span><br><span class="line"><span class="string">'weight'</span> : <span class="string">'normal'</span>,</span><br><span class="line"><span class="string">'size'</span>   : <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">#marker size value</span></span><br><span class="line">ms = <span class="number">3</span></span><br><span class="line"><span class="comment">#坐标刻度设置</span></span><br><span class="line">plt.rcParams[<span class="string">'xtick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将x周的刻度线方向设置向内</span></span><br><span class="line">plt.rcParams[<span class="string">'ytick.direction'</span>] = <span class="string">'in'</span><span class="comment">#将y轴的刻度方向设置向内</span></span><br><span class="line"><span class="comment">#坐标轴范围设置</span></span><br><span class="line">plt.axis([<span class="number">0.9</span>,<span class="number">5.1</span>,<span class="number">-4.5</span>,<span class="number">2.8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入函数表达式</span></span><br><span class="line">x0 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">-3.67009803</span>,<span class="number">-3.40782603</span>,<span class="number">-3.16589303</span>,<span class="number">-3.17546403</span>,<span class="number">-2.97390703</span>]</span><br><span class="line">y2 = [<span class="number">-1.6923971</span>,<span class="number">1.9337329</span>,<span class="number">-0.8673871</span>,<span class="number">-0.7904971</span>,<span class="number">-0.5949971</span>]</span><br><span class="line">y3 = [<span class="number">-4.1635771</span>,<span class="number">-3.7505471</span>,<span class="number">-3.5987971</span>,<span class="number">-3.3103471</span>,<span class="number">-3.3314971</span>]</span><br><span class="line">y4 = [<span class="number">-0.64704003</span>,<span class="number">-0.65326003</span>,<span class="number">-0.64105003</span>]</span><br><span class="line">y5 = [<span class="number">-3.24590003</span>,<span class="number">-2.82530003</span>,<span class="number">-2.83067003</span>,<span class="number">-2.74542003</span>,<span class="number">-2.76772003</span>]</span><br><span class="line">y6 = [<span class="number">-2.13992003</span>,<span class="number">-1.09997003</span>,<span class="number">-1.59212003</span>,<span class="number">-1.30700003</span>,<span class="number">-1.49897003</span>]</span><br><span class="line">y7 = [<span class="number">-1.09136003</span>,<span class="number">-1.09642003</span>]</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'Cl at n layer'</span>, label_font)</span><br><span class="line">plt.ylabel(<span class="string">'Vacancy formation energy (eV)'</span>, label_font)</span><br><span class="line">my_x_ticks = np.arange(<span class="number">1</span>, <span class="number">5.1</span>, <span class="number">1</span>) </span><br><span class="line">plt.xticks(my_x_ticks)</span><br><span class="line"></span><br><span class="line">plt.yticks(fontproperties = <span class="string">'Times New Roman'</span>, size = <span class="number">10</span>)</span><br><span class="line">plt.xticks(fontproperties = <span class="string">'Times New Roman'</span>, size = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x1,y1,color=<span class="string">'green'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'o'</span>,markersize=ms,label=<span class="string">'Cl at Mg vacancy in pure Mg'</span>)</span><br><span class="line">plt.plot(x1,y2,color=<span class="string">'blue'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'o'</span>,markersize=ms,label=<span class="string">'Cl at Mg vacancy in MgF2'</span>)</span><br><span class="line">plt.plot(x1,y3,color=<span class="string">'blue'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'&gt;'</span>,markersize=ms,label=<span class="string">'Cl at F vacancy in MgF2'</span>)</span><br><span class="line">plt.plot(x,y4,color=<span class="string">'red'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'o'</span>,markersize=ms,label=<span class="string">'cl at Mg vacancy in Mg(OH)2'</span>)</span><br><span class="line">plt.plot(x1,y5,color=<span class="string">'red'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'p'</span>,markersize=ms,label=<span class="string">'cl at H vacancy in Mg(OH)2'</span>)</span><br><span class="line">plt.plot(x1,y6,color=<span class="string">'red'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'s'</span>,markersize=ms,label=<span class="string">'cl at O vacancy in Mg(OH)2'</span>)</span><br><span class="line">plt.plot(x0,y7,color=<span class="string">'red'</span>,linestyle=<span class="string">''</span>,marker=<span class="string">'*'</span>,markersize=ms,label=<span class="string">'cl at interstitial in Mg(OH)2'</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>, <span class="number">-1</span>,<span class="number">6</span>, colors = <span class="string">"red"</span>, linestyles = <span class="string">"dashed"</span>,linewidth=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">'upper right'</span>, prop=legend_font) </span><br><span class="line">plt.tight_layout() <span class="comment">#1.避免图例在图外时显示不全 2.无需裁切图片</span></span><br><span class="line">plt.savefig(<span class="string">'ins.tif'</span>,dpi = <span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>效果图如下：</strong></p>
<p> <img src="/Users/wangyaowei/Documents/Blog/blog/source/images/ins.jpeg" alt="ins"></p>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>python读取文件的常用方法</title>
    <url>/2020/04/06/python%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#适用于文本但不适用于数字</span></span><br><span class="line"><span class="keyword">with</span> open (<span class="string">'test.dat'</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">#pandas读取方法</span></span><br><span class="line">df = pd.read_csv(<span class="string">'test.dat'</span>,encoding = <span class="string">'GBK'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data1 = pd.DataFrame(arr1)</span><br><span class="line">data1.to_csv(<span class="string">'data1.csv'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>二元二次图像</title>
    <url>/2020/04/04/%E4%BA%8C%E5%85%83%E4%BA%8C%E6%AC%A1%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逻辑回归 平方差画图</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># mpl_toolkits是matplotlib官方的工具包 mplot3d是用来画三维图像的工具包</span></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="comment"># pyplot 是一个有命令风格的的函数集合，与matlab相似。</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个图像窗口</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 在图像窗口添加3d坐标轴</span></span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用np.linspace定义 x:范围(-10,10);个数为100</span></span><br><span class="line">x = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 定义 y:范围(-3,3);个数为50</span></span><br><span class="line">y = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 创建x-y平面网络</span></span><br><span class="line">x,y = np.meshgrid(x,y)</span><br><span class="line"><span class="comment"># 定义函数 r=1/2*(x-y)^2</span></span><br><span class="line"><span class="comment"># r = 1/2*np.square(x-y)</span></span><br><span class="line">r = x**<span class="number">2</span>+y**<span class="number">2</span>-math.sqrt(<span class="number">2</span>)*x*y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数显示为3d  rstride 和 cstride 代表 row(行)和column(列)的跨度 get_cmap为色图分类 </span></span><br><span class="line">ax.plot_surface(x,y,r,rstride = <span class="number">1</span>, cstride = <span class="number">1</span>,cmap=<span class="string">'rainbow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 投影</span></span><br><span class="line"><span class="comment"># ax.contourf(x,y,r,zdir= 'x', offset = (-2),cmap=plt.get_cmap('rainbow')) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示创建的图像</span></span><br><span class="line">plt.savefig(<span class="string">'minus.tif'</span>, dpi=<span class="number">200</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>实际效果如图：</strong></p>
<p> <a href="../images/minus.tif">minus.tif</a> </p>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>对称slab按照层数松弛上下表面python脚本</title>
    <url>/2020/04/04/%E5%AF%B9%E7%A7%B0slab%E6%8C%89%E7%85%A7%E5%B1%82%E6%95%B0%E6%9D%BE%E5%BC%9B%E4%B8%8A%E4%B8%8B%E8%A1%A8%E9%9D%A2python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fix_atom_v1.0</span></span><br><span class="line"><span class="comment"># 仅针对于pymatgen生成的标准POSCAR，若其他格式POSCAR导致坐标位数不同需要更改脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#Need Modifycation!!!</span></span><br><span class="line"><span class="comment">#对称表面上下可以动的层数，读取当前文件下POSCAR内容</span></span><br><span class="line"><span class="comment"># layers = eval(input("请输入slab上下要松弛的层数"))</span></span><br><span class="line">layers = <span class="number">3</span></span><br><span class="line">f = open(<span class="string">'POSCAR'</span>, <span class="string">'r'</span>)</span><br><span class="line">lines = f.readlines()</span><br><span class="line">f.close()</span><br><span class="line">new = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    new.append(line.strip())</span><br><span class="line">os.rename(<span class="string">'POSCAR'</span>,<span class="string">'POSCAR_unfixed_atoms'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上Selective Dynamics变成可改变模式的</span></span><br><span class="line">new.insert(<span class="number">7</span>,<span class="string">'Selective Dynamics'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#去掉最后的字母元素符号</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line">    <span class="keyword">if</span> new[i][<span class="number">-2</span>] == <span class="string">' '</span>:</span><br><span class="line">        new[i] = new[i][<span class="number">0</span>:<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new[i] = new[i][<span class="number">0</span>:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得slab层数及坐标</span></span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line"><span class="comment">#     num = 1</span></span><br><span class="line"><span class="comment">#     while new[i][-num] != ' ':</span></span><br><span class="line"><span class="comment">#         num += 1</span></span><br><span class="line"><span class="comment">#     print(num-1)</span></span><br><span class="line"><span class="comment">#     print(i,new[i][1-num:])</span></span><br><span class="line">    ls.append(eval(new[i][<span class="number">-8</span>:]))</span><br><span class="line">ls = list((set(ls)))</span><br><span class="line">ls.sort()</span><br><span class="line">print(<span class="string">"此slab模型共有&#123;&#125;层, 松弛上下&#123;&#125;层"</span>.format(len(ls),layers))</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上FT模式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line">    <span class="keyword">if</span> eval(new[i][<span class="number">-8</span>:]) <span class="keyword">in</span> ls[<span class="number">0</span>:layers]:</span><br><span class="line">        new[i] = new[i]+<span class="string">"  T T T"</span></span><br><span class="line">    <span class="keyword">elif</span> eval(new[i][<span class="number">-8</span>:]) <span class="keyword">in</span> ls[-layers:]:</span><br><span class="line">        new[i] = new[i]+<span class="string">"  T T T"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new[i] = new[i]+<span class="string">"  F F F"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">f = open(<span class="string">'POSCAR'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">for</span> para <span class="keyword">in</span> new:</span><br><span class="line">    f.write(para)</span><br><span class="line">    f.write(<span class="string">'\n'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>对称slab按照距离松弛上下表面python脚本</title>
    <url>/2020/04/04/%E5%AF%B9%E7%A7%B0slab%E6%8C%89%E7%85%A7%E8%B7%9D%E7%A6%BB%E6%9D%BE%E5%BC%9B%E4%B8%8A%E4%B8%8B%E8%A1%A8%E9%9D%A2python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#Need Modifycation!!!</span></span><br><span class="line"><span class="comment">#对称表面上下可以动的距离，读取当前文件下POSCAR内容</span></span><br><span class="line"><span class="comment"># distance = eval(input("请输入slab上下要松弛的距离(单位A)"))</span></span><br><span class="line">distance = <span class="number">3</span></span><br><span class="line">f = open(<span class="string">'POSCAR'</span>, <span class="string">'r'</span>)</span><br><span class="line">lines = f.readlines()</span><br><span class="line">f.close()</span><br><span class="line">new = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    new.append(line.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment">#沿c方向slab距离</span></span><br><span class="line">slab_c = eval(new[<span class="number">4</span>].split(<span class="string">" "</span>)[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">'POSCAR'</span>,<span class="string">'POSCAR_unfixed_atoms'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上Selective Dynamics变成可改变模式的</span></span><br><span class="line">new.insert(<span class="number">7</span>,<span class="string">'Selective Dynamics'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#去掉最后的字母元素符号</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line">    <span class="keyword">if</span> new[i][<span class="number">-2</span>] == <span class="string">' '</span>:</span><br><span class="line">        new[i] = new[i][<span class="number">0</span>:<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new[i] = new[i][<span class="number">0</span>:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得slab层数及坐标</span></span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line"><span class="comment">#     num = 1</span></span><br><span class="line"><span class="comment">#     while new[i][-num] != ' ':</span></span><br><span class="line"><span class="comment">#         num += 1</span></span><br><span class="line"><span class="comment">#     print(num-1)</span></span><br><span class="line"><span class="comment">#     print(i,new[i][1-num:])</span></span><br><span class="line">    ls.append(eval(new[i][<span class="number">-8</span>:]))</span><br><span class="line">ls = list((set(ls)))</span><br><span class="line">ls.sort()</span><br><span class="line">print(<span class="string">"此slab模型高度为&#123;&#125;A, 松弛上下&#123;&#125;A"</span>.format(slab_c,distance))</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上FT模式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>,len(new)):</span><br><span class="line">    <span class="keyword">if</span> eval(new[i][<span class="number">-8</span>:])*slab_c &lt;= (ls[<span class="number">0</span>]*slab_c+<span class="number">3</span>):</span><br><span class="line">        new[i] = new[i]+<span class="string">"  T T T"</span></span><br><span class="line">    <span class="keyword">elif</span> eval(new[i][<span class="number">-8</span>:])*slab_c &gt;= (ls[<span class="number">-1</span>]*slab_c<span class="number">-3</span>):</span><br><span class="line">        new[i] = new[i]+<span class="string">"  T T T"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new[i] = new[i]+<span class="string">"  F F F"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">f = open(<span class="string">'POSCAR'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">for</span> para <span class="keyword">in</span> new:</span><br><span class="line">    f.write(para)</span><br><span class="line">    f.write(<span class="string">'\n'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>cif格式转换vasp格式python脚本(cif_to_vasp)</title>
    <url>/2020/04/04/cif%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2vasp%E6%A0%BC%E5%BC%8Fpython%E8%84%9A%E6%9C%AC-cif-to-vasp/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>python 3</p>
<p><a href="https://wiki.fysik.dtu.dk/ase/#atomic-simulation-environment" target="_blank" rel="noopener">Atomic Simulation Environment</a></p>
<h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> io</span><br><span class="line">atoms = io.read(jobname+<span class="string">'.cif'</span>)</span><br><span class="line">atoms.write(<span class="string">'POSCAR'</span>, format = <span class="string">'vasp'</span>)</span><br></pre></td></tr></table></figure>

<p>基于ase的三行脚本即可将.cif文件转换为vasp格式文件，然而由于ase包的问题，转换后的POSCAR文件第六行缺少对应的元素符号，需额外通过python脚本处理生成好的POSCAR文件来达到最终目的。</p>
<p><strong>完整代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前目录下全部.cif文件名称，其他目录下的.cif需要给出完整路径并且用os.chdir改变工作路径</span></span><br><span class="line">files_bak = os.listdir(<span class="string">'./'</span>)</span><br><span class="line">files = []</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files_bak:</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">-4</span>:] == <span class="string">'.cif'</span>:</span><br><span class="line">        files.append(f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#先将所有的cif用ase转换为poscar文件，并删除原来的cif文件        </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> files:</span><br><span class="line">    atoms = io.read(i)</span><br><span class="line">    atoms.write(<span class="string">'temp.vasp'</span>, format = <span class="string">'vasp'</span>)</span><br><span class="line">    os.remove(i)</span><br><span class="line">    <span class="comment">#将现有的cif文件第六行加上第一行的元素符号，存为最终的POSCAR文件</span></span><br><span class="line">    f = open(i[<span class="number">0</span>:<span class="number">-4</span>]+<span class="string">'.vasp'</span>,<span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'temp.vasp'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> p:</span><br><span class="line">        os.remove(<span class="string">'temp.vasp'</span>)</span><br><span class="line">        <span class="comment">#在readlines()读取元素时，不必将每个元素结尾的\n用.strip()函数去掉，因为再次写入会自动达到换行效果</span></span><br><span class="line">        lines = p.readlines()</span><br><span class="line">        lines.insert(<span class="number">5</span>,lines[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lines:</span><br><span class="line">            f.write(l)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><ul>
<li>windows平台，MS建好模型后通过坚果云共享到MAC系统中，<strong>cif一定几率变成二进制文件</strong>报错</li>
</ul>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>材料光学性质(一)</title>
    <url>/2020/03/31/%E6%9D%90%E6%96%99%E5%85%89%E5%AD%A6%E6%80%A7%E8%B4%A8(%E4%B8%80)/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="光学性质基础"><a href="#光学性质基础" class="headerlink" title="光学性质基础"></a>光学性质基础</h3><h4 id="wave-particle-duality-by-Einstein"><a href="#wave-particle-duality-by-Einstein" class="headerlink" title="wave particle duality(by Einstein)"></a>wave particle duality(by Einstein)</h4><p><strong>photoelectric effect</strong>:the emission of <a href="https://en.wikipedia.org/wiki/Electron" target="_blank" rel="noopener">electrons</a> or other <a href="https://en.wikipedia.org/wiki/Charge_carrier" target="_blank" rel="noopener"><em>free carriers</em></a> when <a href="https://en.wikipedia.org/wiki/Electromagnetic_radiation" target="_blank" rel="noopener">electromagnetic radiation</a>, like <a href="https://en.wikipedia.org/wiki/Light" target="_blank" rel="noopener">light,</a> hits a material. Electrons emitted in this manner can be called <em>photoelectrons</em>.</p>
<h4 id="Plank-equation"><a href="#Plank-equation" class="headerlink" title="Plank equation"></a>Plank equation</h4><p>E=hv, h=6.626× 10-34 m2 kg / s</p>
<h4 id="The-de-Broglie-Relations"><a href="#The-de-Broglie-Relations" class="headerlink" title="The de Broglie Relations"></a>The de Broglie Relations</h4><p>p=hv=hc/λ</p>
<h4 id="Standing-and-Traveling-waves"><a href="#Standing-and-Traveling-waves" class="headerlink" title="Standing and Traveling waves"></a>Standing and Traveling waves</h4><p><strong>驻波</strong>（<strong>standing wave</strong>或<strong>stationary wave</strong>）为两个<a href="https://zh.wikipedia.org/wiki/波長" target="_blank" rel="noopener">波长</a>、<a href="https://zh.wikipedia.org/wiki/週期" target="_blank" rel="noopener">周期</a>、<a href="https://zh.wikipedia.org/wiki/頻率" target="_blank" rel="noopener">频率</a>和波速皆相同的<a href="https://zh.wikipedia.org/wiki/正弦信号" target="_blank" rel="noopener">正弦波</a>相向行进<a href="https://zh.wikipedia.org/wiki/干涉_(物理学)" target="_blank" rel="noopener">干涉</a>而成的合成波。与<a href="https://zh.wikipedia.org/wiki/行波" target="_blank" rel="noopener">行波</a>不同，驻波的波形无法前进，因此无法传播<a href="https://zh.wikipedia.org/wiki/能量" target="_blank" rel="noopener">能量</a>，故名之。驻波最大值和最小值在某一固定点不动</p>
<p><strong>行波（travelling wave）</strong>是指平面波在传输线上的一种传输状态，其幅度沿传播方向按指数规律变化，相位沿传输线按线性规律变化。</p>
<blockquote>
<p>波是y=sinx,行波就是波要在走，y=sin(x-t)就可表示行波, 可以看到t=0时波是y=sinx, t=1时y=sin(x-1). 每一刻波都在往右走，这就是行波。y=sin(x+t)，也是行波，但是在往左走。</p>
<p>如果俩个完全一样，仅方向不一样的行波y=sin(x-t)和y=sin(x+t)相遇，公式变成y=2sinxcost,可以看到只要x=0，或者半波长整数倍的时候，y=0，代表这时不管t怎么变，这些点永远不动，这些点就是驻波的波节，在看除波节外的任一点，t=0时，y达到正幅值，t=1/4周期时，y=0,这时波是一条直线，所有值都是零，t=1/2周期时，y达到负幅值，所以y=2sinxcost就是驻波，波节不动，其余地方一直在震动。</p>
</blockquote>
<p>？？？相速度和群速度？？？</p>
<h4 id="some-quiz"><a href="#some-quiz" class="headerlink" title="some quiz"></a>some quiz</h4><ol>
<li><strong>Can gravity bend the light?</strong>(Yes, the star is not at the position we observe because of the sun)</li>
<li><strong>What is the princeple of fiber?</strong>(Total reflection)</li>
<li><strong>Are there any loss during the transpotation of fiber? If yes, where is the loss from?</strong>(yes, they from:a.any materials can absorb some light. b.the fiber is not all straight along the whole road. if there is a corner, 90 degree, which do not satisfy the prerequest of the total reflection. Herein, there will be some loss.)</li>
<li><strong>What are the conditions for total reflection to occur?</strong>(a.from n larger medium to n small medium, n is refraction index b. staify critical angle)</li>
<li><strong>What’s the difference between mechanical wave and electromagnetic wave?</strong>(transportation medium)</li>
<li><strong>Waht is the wave number?</strong>(k=2π/λ)</li>
</ol>
<h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>Isotropic:各向同性</p>
<p>Sodium:钠</p>
<p>copper:铜</p>
<p>Zinc:锌</p>
<p>Prism:棱镜</p>
<p>reflection:反射</p>
<p>refraction:折射</p>
]]></content>
      <categories>
        <category>材料物理性能</category>
      </categories>
  </entry>
  <entry>
    <title>Python常用技巧总结</title>
    <url>/2020/03/31/Python%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h4><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中，可减少命名额外的变量。索引默认从0开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通的for循环</span></span><br><span class="line">&gt;&gt;&gt;i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> seq:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, seq[i]</span><br><span class="line"><span class="meta">... </span>    i +=<span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环使用enumerate</span></span><br><span class="line">&gt;&gt;&gt;seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, element</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure>

<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape <span class="comment">#数组形状</span></span><br><span class="line">numpy.around(a, decimals=<span class="number">0</span>) <span class="comment">#0为想保存的小数个数</span></span><br><span class="line">np.transpose(arr) <span class="comment">#数组转置</span></span><br><span class="line"><span class="comment"># SVD函数</span></span><br><span class="line">np.linalg.svd(a,full_matrices=<span class="number">1</span>,compute_uv=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#参数：</span></span><br><span class="line"><span class="comment">#a是一个形如(M,N)矩阵</span></span><br><span class="line"><span class="comment">#full_matrices的取值是为0或者1，默认值为1，这时u的大小为(M,M)，v的大小为(N,N)。否则u的大小为(M,K)，v的大小为(K,N) ，K=min(M,N)。</span></span><br><span class="line"><span class="comment">#compute_uv的取值是为0或者1，默认值为1，表示计算u,s,v。为0的时候只计算s。</span></span><br></pre></td></tr></table></figure>





<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.iat[<span class="number">0</span>,<span class="number">0</span>] <span class="comment">#特定位置元素</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">'列名'</span>] <span class="comment">#直接取出一列</span></span><br><span class="line">df[<span class="string">'列名1'</span>, <span class="string">'列名2'</span>] <span class="comment">#取出两列</span></span><br><span class="line"></span><br><span class="line">df.loc[<span class="string">'行名1'</span>:<span class="string">'行名2'</span>] <span class="comment">#选取行名1到行名2的所有行</span></span><br><span class="line">df.iloc[<span class="number">2</span>:<span class="number">3</span>] <span class="comment">#选取第三行到第四行</span></span><br><span class="line"></span><br><span class="line">df.iloc[a:b,c:d] <span class="comment">#同时选取行列</span></span><br></pre></td></tr></table></figure>

<img src="/2020/03/31/Python%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/pandas_average.png" style="zoom:50%;">

<p>筛选x列小于18.69的数据并且对第二列求平均</p>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 散点图，alpha透明度，color为内部颜色，color=' '无内部颜色，s标记大小</span></span><br><span class="line">plt.scatter(x,y,alpha=<span class="number">0.6</span>,marker = <span class="string">'s'</span>,color=<span class="string">"w"</span>,linewidths=<span class="number">1</span>,s=<span class="number">50</span>,edgecolors=<span class="string">'black'</span>)</span><br><span class="line"><span class="comment"># 生成网格</span></span><br><span class="line"><span class="comment"># which : &#123;'major', 'minor', 'both'&#125;, optional</span></span><br><span class="line"><span class="comment"># The grid lines to apply the changes on.</span></span><br><span class="line"><span class="comment"># axis : &#123;'both', 'x', 'y'&#125;, optional</span></span><br><span class="line"><span class="comment"># The axis to apply the changes on.</span></span><br><span class="line">plt.grid(which=<span class="string">'major'</span>, axis=<span class="string">'both'</span>, **kwargs)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>对不收敛vasp结果将CONTCAR改为POSCAR继续计算bash脚本</title>
    <url>/2020/03/31/%E5%AF%B9%E4%B8%8D%E6%94%B6%E6%95%9Bvasp%E7%BB%93%E6%9E%9C%E5%B0%86CONTCAR%E6%94%B9%E4%B8%BAPOSCAR%E7%BB%A7%E7%BB%AD%E8%AE%A1%E7%AE%97bash%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *;</span><br><span class="line">do	</span><br><span class="line">		<span class="comment">#如果i是文件夹则打开i</span></span><br><span class="line">    <span class="keyword">if</span> [ -d $i ];then</span><br><span class="line">        cd $i</span><br><span class="line">        <span class="keyword">if</span> grep -q <span class="string">"to POSCAR and continue"</span> vasp.out;then</span><br><span class="line">            pwd</span><br><span class="line">            mv CONTCAR POSCAR</span><br><span class="line">            sbatch -N <span class="number">2</span> ~/bin/vasp_std.slurm</span><br><span class="line">        <span class="comment">#若结果收敛则输出数字0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            echo <span class="number">0</span></span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>bash基础语法</title>
    <url>/2020/03/31/bash%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 取值列表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    各种操作</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>举例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算1-100的和</span></span><br><span class="line">ans=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">let</span> ans+=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ans</span></span><br></pre></td></tr></table></figure>

<h4 id="if-else条件判断"><a href="#if-else条件判断" class="headerlink" title="if else条件判断"></a>if else条件判断</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#elif可以省略</span></span><br><span class="line"><span class="keyword">if</span> 条件判断；then</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">elif</span></span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">elif</span></span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux操作系统与常用软件</category>
      </categories>
  </entry>
  <entry>
    <title>Kmeans聚类算法实例-31省城市消费水平</title>
    <url>/2020/03/24/Kmeans%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B-31%E7%9C%81%E5%9F%8E%E5%B8%82%E6%B6%88%E8%B4%B9%E6%B0%B4%E5%B9%B3/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>无监督学习简介-聚类和降维</title>
    <url>/2020/03/23/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B-%E8%81%9A%E7%B1%BB%E5%92%8C%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="无监督学习的目标"><a href="#无监督学习的目标" class="headerlink" title="无监督学习的目标"></a>无监督学习的目标</h3><p>利用<strong>无标签的数据</strong>学习数据的分布或数据与数据之间的关系被称作无监督学习。</p>
<ul>
<li><p>有监督学习和无监督学习的最大区别在于数据是否有标签</p>
</li>
<li><p>无监督学习最常应用的场景是<strong>聚类(clustering)</strong>和<strong>降维(Dimension Reduction)</strong></p>
</li>
<li><p>聚类(clustering)，就是根据数据的“相似性”将数据分为多类的过程。评估两个不同样本之间的“相似性”，通常使用的方法就是计算两个样本之间的“距离”。使用不同的方法计算样本间的距离会关系到聚类结果的好坏。距离的常见算法有欧氏距离，曼哈顿距离，马氏距离，夹角余弦。</p>
</li>
<li><p>降维，就是在保证数据所具有的代表性特性或者分布的情况下，将高维数据转化为低维数据的过程。降维可以精简数据和数据可视化。</p>
</li>
</ul>
<h3 id="聚类常见算法-sklearn-cluster"><a href="#聚类常见算法-sklearn-cluster" class="headerlink" title="聚类常见算法(sklearn.cluster)"></a>聚类常见算法(sklearn.cluster)</h3><table>
<thead>
<tr>
<th align="center">算法名称</th>
<th align="center">参数</th>
<th align="center">可拓展性</th>
<th align="center">相似性度量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">K-means</td>
<td align="center">聚类个数</td>
<td align="center">大规模数据</td>
<td align="center">点间距离</td>
</tr>
<tr>
<td align="center">DBSCAN</td>
<td align="center">邻域大小</td>
<td align="center">大规模数据</td>
<td align="center">点间距离</td>
</tr>
<tr>
<td align="center">Gaussian Mixtures</td>
<td align="center">聚类个数及其他超参</td>
<td align="center">复杂度高，不适合处理大规模数据</td>
<td align="center">马氏距离</td>
</tr>
<tr>
<td align="center">Birch</td>
<td align="center">分支因子，阈值等其他超参</td>
<td align="center">大规模数据</td>
<td align="center">两点间的欧式距离</td>
</tr>
</tbody></table>
<h3 id="常见降维算法-sklearn-decomposition"><a href="#常见降维算法-sklearn-decomposition" class="headerlink" title="常见降维算法(sklearn.decomposition)"></a>常见降维算法(sklearn.decomposition)</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">参数</th>
<th align="center">可拓展性</th>
<th align="center">适用任务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PCA</td>
<td align="center">所降维度及其他超参</td>
<td align="center">大规模数据</td>
<td align="center">信号处理等</td>
</tr>
<tr>
<td align="center">FastICA</td>
<td align="center">所降维度及其他超参</td>
<td align="center">超大规模数据</td>
<td align="center">图形图像特征提取</td>
</tr>
<tr>
<td align="center">NMF</td>
<td align="center">所降维度及其他超参</td>
<td align="center">大规模数据</td>
<td align="center">图形图像特征提取</td>
</tr>
<tr>
<td align="center">LDA</td>
<td align="center">所降维度及其他超参</td>
<td align="center">大规模数据</td>
<td align="center">文本数据，主题挖掘</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>sklearn库中常用数据集及调用方法</title>
    <url>/2020/03/23/sklearn%E5%BA%93%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%8A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="常用数据集"><a href="#常用数据集" class="headerlink" title="常用数据集"></a>常用数据集</h3><table>
<thead>
<tr>
<th>数据集名称</th>
<th>调用方式</th>
<th>适用算法</th>
<th>数据规模</th>
</tr>
</thead>
<tbody><tr>
<td>波士顿房价数据集</td>
<td>load_boston()</td>
<td>回归</td>
<td>506*13</td>
</tr>
<tr>
<td>鸢尾花数据集</td>
<td>load_iris()</td>
<td>分类</td>
<td>150*4</td>
</tr>
<tr>
<td>糖尿病数据集</td>
<td>load_diabetes()</td>
<td>回归</td>
<td>442*10</td>
</tr>
<tr>
<td>手写数字数据集</td>
<td>load_digits()</td>
<td>分类</td>
<td>5620*64</td>
</tr>
<tr>
<td>Olivetti 脸部图像数据集</td>
<td>fetch_olivetti_faces()</td>
<td>降维</td>
<td>400<em>64</em>64</td>
</tr>
<tr>
<td>新闻分类数据集</td>
<td>fetch_20newsgroups()</td>
<td>分类</td>
<td>-</td>
</tr>
<tr>
<td>带标签的人脸数据集</td>
<td>fetch_lfw_people()</td>
<td>分类；降维</td>
<td>-</td>
</tr>
<tr>
<td>路透社新闻语料数据集</td>
<td>fetch_rcv1()</td>
<td>分类</td>
<td>804414*47236</td>
</tr>
</tbody></table>
<p><code>sklearn.datasets.load_boston</code></p>
<p>其重要参数为：</p>
<p>•<strong>return_X_y</strong>:表示是否返回target（即价格），默认为False，只返回data（即属性）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>boston = load_boston</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( boston.data.shape)</span><br><span class="line">(<span class="number">506</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sklearn库的基本功能"><a href="#sklearn库的基本功能" class="headerlink" title="sklearn库的基本功能"></a>sklearn库的基本功能</h3><h4 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h4><table>
<thead>
<tr>
<th>分类模型</th>
<th>加载模块</th>
</tr>
</thead>
<tbody><tr>
<td>最近邻算法</td>
<td>neighbors.NearestNeighbors</td>
</tr>
<tr>
<td>支持向量机</td>
<td>svm.SVC</td>
</tr>
<tr>
<td>朴素贝叶斯</td>
<td>naive_bayes.GaussianNB</td>
</tr>
<tr>
<td>决策树</td>
<td>tree.DecisionTreeClassifier</td>
</tr>
<tr>
<td>集成方法</td>
<td>ensemble.BaggingClassifier</td>
</tr>
<tr>
<td>神经网络</td>
<td>neural_network.MLPClassifier</td>
</tr>
</tbody></table>
<h4 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h4><table>
<thead>
<tr>
<th>回归模型</th>
<th>加载模块</th>
</tr>
</thead>
<tbody><tr>
<td>岭回归</td>
<td>linear_model.Ridge</td>
</tr>
<tr>
<td>Lasso回归</td>
<td>linear_model.Lasso</td>
</tr>
<tr>
<td>弹性网络</td>
<td>linear_model.ElasticNet</td>
</tr>
<tr>
<td>最小角回归</td>
<td>linear_model.Lars</td>
</tr>
<tr>
<td>贝叶斯回归</td>
<td>linear_model.BayesianRidge</td>
</tr>
<tr>
<td>逻辑回归</td>
<td>linear_model.LogisticRegression</td>
</tr>
<tr>
<td>多项式回归</td>
<td>preprocessing. PolynomialFeatures</td>
</tr>
</tbody></table>
<h4 id="聚类任务"><a href="#聚类任务" class="headerlink" title="聚类任务"></a>聚类任务</h4><table>
<thead>
<tr>
<th>聚类方法</th>
<th>加载模块</th>
</tr>
</thead>
<tbody><tr>
<td>K-means</td>
<td>cluster.KMeans</td>
</tr>
<tr>
<td>AP聚类</td>
<td>cluster.AffinityPropagation</td>
</tr>
<tr>
<td>均值漂移</td>
<td>cluster.MeanShift</td>
</tr>
<tr>
<td>层次聚类</td>
<td>cluster.AgglomerativeClustering</td>
</tr>
<tr>
<td>DBSCAN</td>
<td>cluster.DBSCAN</td>
</tr>
<tr>
<td>BIRCH</td>
<td>cluster.Birch</td>
</tr>
<tr>
<td>谱聚类</td>
<td>cluster.SpectralClustering</td>
</tr>
</tbody></table>
<h4 id="降维人物"><a href="#降维人物" class="headerlink" title="降维人物"></a>降维人物</h4><table>
<thead>
<tr>
<th>降维方法</th>
<th>加载模块</th>
</tr>
</thead>
<tbody><tr>
<td>主成分分析</td>
<td>decomposition.PCA</td>
</tr>
<tr>
<td>截断SVD和LSA</td>
<td>decomposition.TruncatedSVD</td>
</tr>
<tr>
<td>字典学习</td>
<td>decomposition.SparseCoder</td>
</tr>
<tr>
<td>因子分析</td>
<td>decomposition.FactorAnalysis</td>
</tr>
<tr>
<td>独立成分分析</td>
<td>decomposition.FastICA</td>
</tr>
<tr>
<td>非负矩阵分解</td>
<td>decomposition.NMF</td>
</tr>
<tr>
<td>LDA</td>
<td>decomposition.LatentDirichletAllocation</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>能斯特方程</title>
    <url>/2020/03/23/Nernst-equation/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="基本概念梳理"><a href="#基本概念梳理" class="headerlink" title="基本概念梳理"></a>基本概念梳理</h3><ul>
<li><em>$E_o$</em>, the <strong>standard equilibrium potential</strong> (or standard electrode potential), is defined as the equilibrium potential of an electrode reaction when all components are in their standard states, measured against the standard hydrogen electrode (SHE).</li>
</ul>
<blockquote>
<p>标准电极电位是反应处在标准状态下(298K,所有离子的浓度都是1mol/L)，的平衡电位，其数值可在标准电位表中查出，也可以根据热力学上的数据自行运算。</p>
</blockquote>
<p>eg：在腐蚀电化学原理(曹楚南)一书中，常见金属相对于H电极的标准平衡电位是：</p>
<table>
<thead>
<tr>
<th align="center">反应</th>
<th align="center">SHE(V)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$Li$=$Li^+$+$e^-$</td>
<td align="center">-3.024</td>
</tr>
<tr>
<td align="center">Ca=Ca^2+^+2e^-^</td>
<td align="center">-2.87</td>
</tr>
<tr>
<td align="center">Mg=Mg^2+^+2e^-^</td>
<td align="center">-2.34</td>
</tr>
<tr>
<td align="center">Al=Al^3+^+3e^-^</td>
<td align="center">-1.67</td>
</tr>
<tr>
<td align="center">Zn=Zn^2+^+2e^-^</td>
<td align="center">-0.762</td>
</tr>
</tbody></table>
<p>自己计算的方法如下，首先在<a href="https://job-stiftung.de/index.php?id=63" target="_blank" rel="noopener">德国爱德华久保热力学和物质动力学基金会</a>找到对应离子的化学势；</p>
<blockquote>
<p>网站的数据遵循标准：(1)在标准状态下 (T = 298 K, p = 101,3 kPa)，(2)在溶液标准浓度下 (1000 mol/m3)，(3)处于理想状态下，没有分子间相互作用的气体或溶解物质，(4)由元素的天然同位素组成的所有物质。</p>
<p>单位μ代表kJ/mol，1 eV/atom = 96.49 kJ/mol，网站中“,”代表小数点</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">网站数据(μ)</th>
<th align="center">ev/atom</th>
<th align="center">计算平衡电位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Li^+^</td>
<td align="center">-293.80</td>
<td align="center">-3.0449</td>
<td align="center">-3.0449</td>
</tr>
<tr>
<td align="center">Ca^2+^</td>
<td align="center">-553.04</td>
<td align="center">-5.7316</td>
<td align="center">-2.8658</td>
</tr>
<tr>
<td align="center">Mg^2+^</td>
<td align="center">-456.01</td>
<td align="center">4.726</td>
<td align="center">-2.363</td>
</tr>
<tr>
<td align="center">Al^3+^</td>
<td align="center">-485.34</td>
<td align="center">-5.03</td>
<td align="center">-1.6767</td>
</tr>
<tr>
<td align="center">Zn^2+^</td>
<td align="center">-147.03</td>
<td align="center">-1.5238</td>
<td align="center">-0.7619</td>
</tr>
</tbody></table>
<ul>
<li><em>$E_e$</em>,equilibrium potential of an electrode, 平衡电极电位。大多数时候，反应都无法在标准状态下进行。由于此时离子浓度较标准状态下发生变化，平衡随之移动，平衡电位也会相继发生改变。</li>
<li>反应的氧化态和还原态，注意能斯特方程的浓度方法，+氧化态在上面的浓度</li>
</ul>
<p>Oxidised State + <em>ne</em>-  ⇌ Reduced State</p>
<h3 id="能斯特方程"><a href="#能斯特方程" class="headerlink" title="能斯特方程"></a>能斯特方程</h3><p>The Nernst equation links the <strong>equilibrium potential</strong> of an electrode, <em>E</em>e, to its <strong>standard potential</strong>(standard equilibium potential), <em>E</em>0, and the concentrations or pressures of the reacting components at a given temperature. It describes the value of <em>E</em>e for a given reaction as a function of the concentrations (or pressures) of all participating chemical species.</p>
<p>In its most fundamental forms, the <strong>Nernst equation for an electrode</strong> is written as:</p>
<p>$E_e$=$E_0$+$\frac{RT}{zF}ln\frac{[Oxidised]}{[Reduced]}$</p>
<p>or</p>
<p>$E_e$=$E_0$+$\frac{2.303RT}{zF}log\frac{[Oxidised]}{[Reduced]}$</p>
<p>or</p>
<p>$E_e$=$E_0$+$\frac{2.303$k_b$T}{ze}log\frac{[Oxidised]}{[Reduced]}$</p>
<p> [Click here for a <a href="https://www.doitpoms.ac.uk/tlplib/pourbaix/nersnt_detailed.php" target="_blank" rel="noopener">full derivation of Nernst equation</a> – popup]</p>
<p><em>R</em> is the universal gas constant (8.3145 J K-1 mol-1)<br><em>T</em> is the absolute temperature<br><em>z</em> is the number of moles of electrons involved in the reaction as written<br><em>F</em> is the Faraday constant (96 485 C per mole of electrons)</p>
<p>The notation [<em>reduced</em>] represents the product of the concentrations (or pressures where gases are involved) of all the species that appear on the reduced side of the electrode reaction, raised to the power of their stoichiometric coefficients. The notation [<em>oxidised</em>] represents the same for the oxidised side of the electrode reaction.</p>
<p>Explanation of <a href="https://www.doitpoms.ac.uk/tlplib/pourbaix/activity.php" target="_blank" rel="noopener">Activity</a></p>
]]></content>
      <categories>
        <category>腐蚀科学</category>
      </categories>
  </entry>
  <entry>
    <title>腐蚀热力学基础</title>
    <url>/2020/03/23/%E8%85%90%E8%9A%80%E7%83%AD%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<a id="more"></a>

<p>Here we shall go through the basic thermodynamics that lies behind use of the Ellingham diagram. First, we will establish the link between the thermodynamics of a reaction and its chemistry.</p>
<p>The Gibbs free energy, <em>G</em>, of a system can be described as the energy in the system available to do work. It is one of the most useful state functions in thermodynamics as it considers only variables contained within the system, at constant temperature and pressure.</p>
<p>It is defined as:</p>
<p>G=H−TS     (1)</p>
<p>Here, <em>T</em> is the temperature of the system and <em>S</em> is the entropy, or disorder, of the system. <em>H</em> is the enthalpy of the system, defined as;</p>
<p>H=U+pv     (2)</p>
<p>Where <em>U</em> is the internal energy, p is the pressure and <em>v</em> is the volume.</p>
<p>To see how the free energy changes when the system is changed by a small amount, we can differentiate the above functions:</p>
<p>dG=dH−TdS−SdT     (3)</p>
<p>and;</p>
<p>dH=dU+pdv+vdp     (4)</p>
<p>From the first law,</p>
<p>dU=dq′−dw     (5)</p>
<p>and from the second law,</p>
<p>dS= dq′T ,    (6)</p>
<p>we see that,</p>
<p>dG=dq′−dw+pdv+vdp−TdS−SdT=−dw+pdv+vdp−SdT=vdp−SdT     (7)</p>
<p>since work, dw=pdv</p>
<p>The above equation shows that if the temperature and pressure are kept constant, we see that the free energy does not change. This means that the Gibbs free energy of a system is unique at each temperature and pressure.</p>
<p>At a constant temperature d<em>T</em> = 0 and so</p>
<p>dG=vdp     (8)</p>
<p>We can find <em>G</em> for the system by integration. To do this we need the system’s equation of state, to give a relationship between <em>v</em> and p.</p>
<p>We will consider an ideal gas. For one mole of an ideal gas the equation of state is;</p>
<p>v= RTp ,    (9)</p>
<p>so (8) becomes</p>
<p>dG= RTdpp     (10)</p>
<p>Integrating:</p>
<p>G=RTln(p)+const.     (11)</p>
<p>This we can express as</p>
<p>G=$G^∘$+RTln(p$p^∘$)     (12)</p>
<p>We define <em>G</em>° to be the standard free energy at the standard pressure, p°. These standard values are nothing more than lower integration constants, but using them is very useful, as we shall see. They are a consequence of the fact that one can only describe energy <em>changes</em> absolutely – there is no absolute energy scale, so the energy value we give to a system is arbitrary.</p>
]]></content>
      <categories>
        <category>腐蚀科学</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas数据特征分析</title>
    <url>/2020/03/22/Pandas%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="数据的排序"><a href="#数据的排序" class="headerlink" title="数据的排序"></a>数据的排序</h3><ul>
<li>操作索引的排序，对索引排序</li>
</ul>
<p><code>.sort_index(axis=0, ascending=True)</code></p>
<p>ascending：递增排序</p>
<p>默认<strong>0轴纵向</strong>排序</p>
<ul>
<li>指定轴上根据数值进行排序，默认升序</li>
</ul>
<p><code>DataFrame.sort_values(by, axis=0, ascending=True)</code></p>
<p>by : axis轴上的某个索引或索引列表，eg:’a’或0</p>
<h3 id="基本的统计分析函数"><a href="#基本的统计分析函数" class="headerlink" title="基本的统计分析函数"></a>基本的统计分析函数</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.argmin() .argmax()</td>
<td align="center">计算数据最大值、最小值所在位置的索引位置（自动索引）</td>
</tr>
<tr>
<td align="center">.idxmin() .idxmax()</td>
<td align="center">计算数据最大值、最小值所在位置的索引（自定义索引）</td>
</tr>
<tr>
<td align="center">.sum()</td>
<td align="center">计算数据的总和，按0轴计算，下同</td>
</tr>
<tr>
<td align="center">.count()</td>
<td align="center">非NaN值的数量</td>
</tr>
<tr>
<td align="center">.mean() .median()</td>
<td align="center">计算数据的算术平均值、算术中位数</td>
</tr>
<tr>
<td align="center">.var() .std()</td>
<td align="center">计算数据的方差、标准差</td>
</tr>
<tr>
<td align="center">.min() .max()</td>
<td align="center">计算数据的最小值、最大值</td>
</tr>
<tr>
<td align="center">.describe()</td>
<td align="center">针对0轴（各列）的统计汇总</td>
</tr>
</tbody></table>
<h3 id="数据的累积统计分析"><a href="#数据的累积统计分析" class="headerlink" title="数据的累积统计分析"></a>数据的累积统计分析</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.cumsum()</td>
<td align="center">依次给出前1、2、…、n个数的和</td>
</tr>
<tr>
<td align="center">.cumprod()</td>
<td align="center">依次给出前1、2、…、n个数的积</td>
</tr>
<tr>
<td align="center">.cummax()</td>
<td align="center">依次给出前1、2、…、n个数的最大值</td>
</tr>
<tr>
<td align="center">.cummin()</td>
<td align="center">依次给出前1、2、…、n个数的最小值</td>
</tr>
<tr>
<td align="center">.rolling(w).sum()</td>
<td align="center">依次计算相邻w个元素的和</td>
</tr>
<tr>
<td align="center">.rolling(w).mean()</td>
<td align="center">依次计算相邻w个元素的算术平均值</td>
</tr>
<tr>
<td align="center">.rolling(w).var()</td>
<td align="center">依次计算相邻w个元素的方差</td>
</tr>
<tr>
<td align="center">.rolling(w).std()</td>
<td align="center">依次计算相邻w个元素的标准差</td>
</tr>
<tr>
<td align="center">.rolling(w).min() .max()</td>
<td align="center">依次计算相邻w个元素的最小值和最大值</td>
</tr>
</tbody></table>
<h3 id="数据的相关分析"><a href="#数据的相关分析" class="headerlink" title="数据的相关分析"></a>数据的相关分析</h3><ul>
<li>相关性：x增大,y增大,正相关。x减小,y减小,负相关。x增大，y无视，不相关。</li>
<li>协方差判断</li>
<li>Pearson相关系数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.8</span>‐<span class="number">1.0</span> 极强相关</span><br><span class="line"><span class="number">0.6</span>‐<span class="number">0.8</span> 强相关</span><br><span class="line"><span class="number">0.4</span>‐<span class="number">0.6</span> 中等程度相关</span><br><span class="line"><span class="number">0.2</span>‐<span class="number">0.4</span> 弱相关</span><br><span class="line"><span class="number">0.0</span>‐<span class="number">0.2</span> 极弱相关或无相关</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.cov()</td>
<td align="center">计算协方差矩阵</td>
</tr>
<tr>
<td align="center">.corr()</td>
<td align="center">计算相关系数矩阵, Pearson、Spearman、Kendall等系数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习入门</title>
    <url>/2020/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<a id="more"></a>

<p>何谓 “机器学习”，学界尚未有统一的定义。但有两个定义特别值得了解：一个来自卡内基梅隆大学的Tom Mitchell教授，一个来自Goodfellow、Bengio 和 Courville合著的经典“花书”《深度学习》。</p>
<p><strong>Tom Mitchell：根据优化过程抽象定义机器学习</strong></p>
<blockquote>
<p>对于某类任务 T 和性能度量 P，如果一个计算机程序在 T 上以 P 衡量的性能随着经验 E 而自我完善，那么我们称这个计算机程序在从经验 E 中学习。</p>
</blockquote>
<h3 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h3><ul>
<li><strong>监督学习(Supervised Algorithms）:</strong>对训练有标签的数据有用，但是对于其他没有标签的数据，则需要预估</li>
<li><strong>无监督学习(Unsupervised Algorithms）:</strong>用于对无标签的数据集（数据没有预处理）的处理，需要发掘其内在关系的时候</li>
<li><strong>强化学习(Reinforcement Algorithms):</strong>介于两者之间，虽然没有精准的标签或者错误信息，但是对于每个可预测的步骤或者行为，会有某种形式的反馈。</li>
<li><strong>半监督学习:</strong></li>
<li><strong>深度学习(Deep Learning):</strong></li>
</ul>
<h3 id="基本的机器学习算法"><a href="#基本的机器学习算法" class="headerlink" title="基本的机器学习算法"></a>基本的机器学习算法</h3><ul>
<li>线性回归算法 Linear Regression</li>
<li>支持向量机算法 (Support Vector Machine,SVM)</li>
<li>最近邻居/k-近邻算法 (K-Nearest Neighbors,KNN)</li>
<li>逻辑回归算法 Logistic Regression</li>
<li>决策树算法 Decision Tree</li>
<li>k-平均算法 K-Means</li>
<li>随机森林算法 Random Forest</li>
<li>朴素贝叶斯算法 Naive Bayes</li>
<li>降维算法 Dimensional Reduction</li>
<li>梯度增强算法 Gradient Boosting</li>
</ul>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>1) <strong>决策树 (Decision Trees)</strong></p>
<p>决策树是一个决策支持工具，它用树形的图或者模型表示决策及其可能的后果，包括随机事件的影响、资源消耗、以及用途。请看下图，随意感受一下决策树长这样的：</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-7c4c6b36873da4a0dbb82fe8d55e5b11_1440w.jpg" alt="v2-7c4c6b36873da4a0dbb82fe8d55e5b11_1440w"></p>
<p>从商业角度看，决策树就是用最少的 Yes/No 问题，尽可能地做出一个正确的决策。它让我们通过一种结构化、系统化的方式解决问题，得到一个有逻辑的结论。</p>
<p>2) <strong>朴素贝叶斯分类 (Naive Bayes Classification)</strong></p>
<p>朴素贝叶斯分类器是一类简单概率分类器，它基于把贝叶斯定理运用在特征之间关系的强独立性假设上。下图是贝叶斯公式 ——P (A|B) 表示后验概率，P (B|A) 表示似然度，P (A) 表示类别的先验概率 (class prior probability)，P (B) 表示做出预测的先验概率 (predictor prior probability)。</p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-5093c94b1556bbf112cce21f08da2cc3_1440w.jpg" alt="v2-5093c94b1556bbf112cce21f08da2cc3_1440w"></p>
<p>现实生活中的应用例子：</p>
<ul>
<li>一封电子邮件是否是垃圾邮件</li>
<li>一篇文章应该分到科技、政治，还是体育类</li>
<li>一段文字表达的是积极的情绪还是消极的情绪？</li>
<li>人脸识别</li>
</ul>
<p>3) <strong>普通最小二乘回归 (Ordinary Least Squares Regression)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-b75d8bf0968ae00525e803e452c4e042_1440w.jpg" alt="v2-b75d8bf0968ae00525e803e452c4e042_1440w"></p>
<p>如果你学过统计学，你可能听过线性回归。至少最小二乘是一种进行线性回归的方法。你可以认为线性回归就是让一条直线用最适合的姿势穿过一组点。有很多方法可以这样做，普通最小二乘法就像这样 —— 你可以画一条线，测量每个点到这条线的距离，然后加起来。最好的线应该是所有距离加起来最小的那根。</p>
<p>线性法表示建模线性模型，而最小二乘法可以最小化该线性模型的误差。</p>
<p>4) <strong>逻辑回归 (Logistic Regression)</strong></p>
<p>逻辑回归是一种非常强大的统计方法，可以把有一个或者多个解释变量的数据，建立为二项式类型的模型，通过用累积逻辑分布的逻辑函数估计概率，测量分类因变量和一个或多个独立变量之间的关系。 </p>
<p>通常，回归在现实生活中的用途如下：</p>
<ul>
<li>信用评估</li>
<li>测量市场营销的成功度</li>
<li>预测某个产品的收益</li>
<li>特定的某天是否会发生地震</li>
</ul>
<p>5) <strong>支持向量机 (Support Vector Machines)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-818dea0b2a5db0d06b4d09c4c35e4add_1440w.jpg" alt="v2-818dea0b2a5db0d06b4d09c4c35e4add_1440w"></p>
<p>SVM 是一种二分算法。假设在 N 维空间，有一组点，包含两种类型，SVM 生成 a (N-1) 维的超平面，把这些点分成两组。比如你有一些点在纸上面，这些点是线性分离的。SVM 会找到一个直线，把这些点分成两类，并且会尽可能远离这些点。</p>
<p>从规模看来，SVM（包括适当调整过的）解决的一些特大的问题有：广告、人类基因剪接位点识别、基于图片的性别检测、大规模图片分类…</p>
<p>6) <strong>集成方法 (Ensemble Methods)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-fb5fe42fac7ae7a423c438640de92cff_1440w.jpg" alt="v2-fb5fe42fac7ae7a423c438640de92cff_1440w"></p>
<p>集成方法吸纳了很多算法，构建一个分类器集合，然后给它们的预测带权重的进行投票，从而进行分类。最初的集成方法是贝叶斯平均法 (Bayesian averaging)，但是最近的算法集还包括了纠错输出编码 (error-correcting output coding) ，bagging 和 boosting</p>
<p>那么集成方法如何工作的？为什么它们比单独的模型更好？</p>
<ul>
<li>它们均衡了偏差：就像如果你均衡了大量的倾向民主党的投票和大量倾向共和党的投票，你总会得到一个不那么偏颇的结果。</li>
<li>它们降低了方差：集合大量模型的参考结果，噪音会小于单个模型的单个结果。在金融上，这叫投资分散原则 (diversification)—— 一个混搭很多种股票的投资组合，比单独的股票更少变故。</li>
<li>它们不太可能过度拟合：如果你有单独的模型不是完全拟合，你结合每个简单方法建模，就不会发生过度拟合 (over-fitting)</li>
</ul>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>7) <strong>聚类算法 (Clustering Algorithms)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-f54021ee5f3458d96bfdbfd633020194_1440w.jpg" alt="v2-f54021ee5f3458d96bfdbfd633020194_1440w"></p>
<p>聚类就是把一组对象分组化的任务，使得在同一组的对象比起其它组的对象，它们彼此更加相似。</p>
<p>每种聚类算法都不同，下面是其中一些：</p>
<ul>
<li>基于图心（Centroid）的算法</li>
<li>基于连接的算法</li>
<li>基于密集度的算法</li>
<li>概率论</li>
<li>降维</li>
<li>神经网络 / 深度学习</li>
</ul>
<p>8) <strong>主成分分析 (Principal Component Analysis)</strong></p>
<p>PCA 是一种统计过程，它通过正交变换把一组可能相关联的变量观察，转换成一组线性非相关的变量的值，这些非相关的变量就是主成分。</p>
<p>PCA 的应用包括压缩、简化数据使之易于学习，可视化。需要注意的是，当决定是否用 PCA 的时候，领域知识特别重要。它不适用于噪音多的数据（所有成分的方差要很高才行）</p>
<p>9) <strong>奇异值分解 (Singular Value Decomposition)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-6ab79925833165f9076bde770beb081e_1440w.jpg" alt="v2-6ab79925833165f9076bde770beb081e_1440w"></p>
<p>线性代数中，SVD 是对一个特别复杂的矩阵做因式分解。比如一个 m*n 的矩阵 M，存在一个分解如 M = UΣV，其中 U 和 V 是酉矩阵，Σ 是一个对角矩阵。</p>
<p>PCA 其实是种简单的 SVD。在计算机图形领域，第一个脸部识别算法就用了 PCA 和 SVD，用特征脸 (eigenfaces) 的线性结合表达脸部图像，然后降维，用简单的方法把脸部和人匹配起来。尽管如今的方法更加复杂，依然有很多是依靠类似这样的技术。</p>
<p>10) <strong>独立成分分析 (Independent Component Analysis)</strong></p>
<p><img src="/Users/wangyaowei/Documents/Blog/blog/source/images/v2-fafdf6f5525015e99a976f66eb64fb06_1440w.jpg" alt="v2-fafdf6f5525015e99a976f66eb64fb06_1440w"></p>
<p>ICA 是一种统计技术。它发掘随机变量、测量数据或者信号的集合中隐含的因素。ICA 定义了一种通用模型，用于观测到的多变量数据，通常是一个巨大的样本数据库。在这一模型中，假设数据变量是一些未知的、潜在的变量的线性组合，而组合方式也是未知的。同时假设，潜在的变量是非高斯分布且相互独立的，我们称之为观测数据的独立成分 (Independent components)。</p>
<p>ICA 与 PCA 有一定关联，但是一种更加有用的技术，在经典方法完全失效的时候，可以发现数据源中的潜在因素。它的应用包括数字图片，文件数据库，经济指数和心理测量。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas</title>
    <url>/2020/03/19/Pandas/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="Pandas库-处理和分析数据最好的第三方库"><a href="#Pandas库-处理和分析数据最好的第三方库" class="headerlink" title="Pandas库-处理和分析数据最好的第三方库"></a>Pandas库-处理和分析数据最好的第三方库</h3><p><a href="https://pandas.pydata.org/docs/#" target="_blank" rel="noopener">官方网站</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<p><strong>两个数据类型</strong>：Series和DataFrame，基于ndarray扩展的数据类型。Pandas注重数据和索引之间的关系。</p>
<h3 id="Series-一维数据类型"><a href="#Series-一维数据类型" class="headerlink" title="Series(一维数据类型)"></a>Series(一维数据类型)</h3><p>由一组数据和其索引组成，就是一维带标签的数据，类似于字典和ndarray的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pands <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#自定义索引</span></span><br><span class="line">b = pd.Series([<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"><span class="comment">#python中NaN表示为空</span></span><br><span class="line"><span class="comment">#获得索引和值</span></span><br><span class="line">b.index</span><br><span class="line">b.values</span><br><span class="line"><span class="comment">#Series可以进行切片</span></span><br><span class="line">b[:<span class="number">3</span>]</span><br><span class="line"><span class="comment">#针对于ndarray进行的操作也可以用于Series</span></span><br><span class="line">np.exp(b)</span><br><span class="line"><span class="comment">#输出大于元素中位数的索引</span></span><br><span class="line">b[b&gt;b.median()]</span><br><span class="line"><span class="comment">#判断键是否在Series中和调取键值</span></span><br><span class="line"><span class="string">'c'</span> <span class="keyword">in</span> b</span><br><span class="line">b.get(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>对齐问题：运算中只运算相对应索引的元素</p>
<h3 id="Dataframe-二维数据类型"><a href="#Dataframe-二维数据类型" class="headerlink" title="Dataframe(二维数据类型)"></a>Dataframe(二维数据类型)</h3><p>多列的数据共用相同索引，表格型数据类型。我理解为c中的数组</p>
<p>有行索引也有列索引。纵向索引index，横向索引column</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = DataFrame(np.nrange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字典转换成DataFrame格式的时候，键会变成表头，值会变成竖着排列的值。</p>
<p>尝试着用DataFrame处理CSV文件</p>
</blockquote>
<p><strong>d.reindex</strong>:重排生成的表格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.reindex(index=<span class="literal">None</span>, columns=<span class="literal">None</span>, …)</span><br><span class="line">index是lie，column是行</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.append(idx)</td>
<td align="center">连接另一个Index对象，产生新的Index对象</td>
</tr>
<tr>
<td align="center">.diff(idx)</td>
<td align="center">计算差集，产生新的Index对象</td>
</tr>
<tr>
<td align="center">.intersection(idx)</td>
<td align="center">计算交集</td>
</tr>
<tr>
<td align="center">.union(idx)</td>
<td align="center">计算并集</td>
</tr>
<tr>
<td align="center">.delete(loc)</td>
<td align="center">删除loc位置处的元素</td>
</tr>
<tr>
<td align="center">.drop()</td>
<td align="center">删除Series和DataFrame指定行或列索引</td>
</tr>
</tbody></table>
<h3 id="数据类型的算术运算"><a href="#数据类型的算术运算" class="headerlink" title="数据类型的算术运算"></a>数据类型的算术运算</h3><ul>
<li>加减乘除算数运算</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.add(d, **argws)</td>
<td align="center">类型间加法运算，可选参数</td>
</tr>
<tr>
<td align="center">.sub(d, **argws)</td>
<td align="center">类型间减法运算，可选参数</td>
</tr>
<tr>
<td align="center">.mul(d, **argws)</td>
<td align="center">类型间乘法运算，可选参数</td>
</tr>
<tr>
<td align="center">.div(d, **argws)</td>
<td align="center">类型间除法运算，可选参数</td>
</tr>
</tbody></table>
<p>eg.<code>b.add(a, fill_value=100)</code></p>
<p>Note：还可以直接利用+-*/运算</p>
<ul>
<li>比较运算</li>
</ul>
<p>&gt;&lt; &gt;= &lt;= == !=进行大小比较，与每个元素都比较，返回布尔值</p>
]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>Matplotlib</title>
    <url>/2020/03/18/Matplotlib/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://matplotlib.org/gallery/index.html" target="_blank" rel="noopener">官方网站</a></p>
<p>matplotlib.pyplot是最方便的子库</p>
<!--more-->

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h3 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多图合并,2行3列第一区域</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出一条折线图，横坐标是这个数的索引(0,1,2,3,4)</span></span><br><span class="line">plt.plot([<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#纵坐标名称</span></span><br><span class="line">plt.ylabel(<span class="string">'grade'</span>) </span><br><span class="line">plt.xlabel(<span class="string">'name'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#其他文本显示</span></span><br><span class="line">plt.title()</span><br><span class="line">plt.text(x,y,内容，fontsize=<span class="number">20</span>)<span class="comment">#在任意位置增加文本，xy是文本开始的坐标</span></span><br><span class="line">plt.annotate()<span class="comment">#在图形中增加带箭头的注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#带箭头的文本</span></span><br><span class="line">plt.annotate(s(解释的内容), xy=arrow_crd(箭头开始位置), </span><br><span class="line">             xytext=text_crd(文本位置), arrowprops=dict(字典描述箭头属性))</span><br><span class="line">plt.annotate(<span class="string">'$\mu=100$'</span>,xy=(<span class="number">2</span>,<span class="number">1</span>),xytxt=(<span class="number">3</span>,<span class="number">1.5</span>),</span><br><span class="line">            arrowprops=dict(facecolor=<span class="string">'black'</span>,shrink=<span class="number">0.1</span>,width=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#展示图形</span></span><br><span class="line">plt.show() </span><br><span class="line"><span class="comment">#保存图形</span></span><br><span class="line">plt.savefig(<span class="string">'test.tif'</span>, dpi = <span class="number">300</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#两个参数，分别控制x轴和y周，先x后y</span></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#设置x，y轴参数范围</span></span><br><span class="line">plt.axis([<span class="number">-1</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置中文字体(改变全局字体，包括坐标轴上的数字)</span></span><br><span class="line">matplotlib.rcParams[<span class="string">'font.family'</span>]=<span class="string">'Kaiti'</span>o<span class="string">r'SimHei'</span></span><br><span class="line">o<span class="string">r'LiSu'</span>o<span class="string">r'FangSong'</span>o<span class="string">r'YouYuan'</span>o<span class="string">r'STSong'</span></span><br><span class="line">matplotlib.rcParams[<span class="string">'font.style'</span>]=<span class="string">'normal'</span> <span class="keyword">or</span> <span class="string">'italic'</span></span><br><span class="line">matplotlib.rcParams[<span class="string">'font.size'</span>]=<span class="string">'large'</span> <span class="keyword">or</span> <span class="string">'x-small'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置中文字体(改变部分字体)</span></span><br><span class="line">在有中文输出的地方，增加一个属性：fontproperties</span><br><span class="line">plt.xlabel(<span class="string">'横轴：时间'</span>, fontproperties=<span class="string">'SimHei'</span>, </span><br><span class="line">           fontsize=<span class="number">20</span>,color = <span class="string">'green'</span>)</span><br><span class="line"><span class="comment">#增加网格</span></span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="plot函数"><a href="#plot函数" class="headerlink" title="plot函数"></a>plot函数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">plt.plot(x,y,format_string, **kwargs)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">x轴上的数据，列表或numpy数组</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">y轴上的数据，列表或numpy数组</td>
</tr>
<tr>
<td align="center">format_string</td>
<td align="center">颜色字符、风格字符和标记字符，可选</td>
</tr>
<tr>
<td align="center">**kwargs</td>
<td align="center">第二组或更多(x,y,format_string)</td>
</tr>
<tr>
<td align="center"><strong>—-颜色—</strong></td>
<td align="center"><strong>—-颜色—</strong></td>
</tr>
<tr>
<td align="center">‘r’,’g’,’b’,’y’,’k’,’w’</td>
<td align="center">红绿蓝黄黑白</td>
</tr>
<tr>
<td align="center">‘c’</td>
<td align="center">青绿色cyan</td>
</tr>
<tr>
<td align="center">‘#008000’</td>
<td align="center">RGB某颜色</td>
</tr>
<tr>
<td align="center">‘m’</td>
<td align="center">洋红色magenta</td>
</tr>
<tr>
<td align="center">‘0.8’</td>
<td align="center">灰度值字符串</td>
</tr>
<tr>
<td align="center"><strong>—直虚线—</strong></td>
<td align="center"><strong>—直虚线—</strong></td>
</tr>
<tr>
<td align="center">‘‐’</td>
<td align="center">实线</td>
</tr>
<tr>
<td align="center">‘‐‐’</td>
<td align="center">破折线</td>
</tr>
<tr>
<td align="center">‘‐.’</td>
<td align="center">点划线</td>
</tr>
<tr>
<td align="center">‘:’</td>
<td align="center">虚线</td>
</tr>
<tr>
<td align="center">‘ ‘</td>
<td align="center">无线条</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">标记字符</th>
<th align="center">说明</th>
<th align="center">标记字符</th>
<th align="center">说明</th>
<th align="center">标记字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘.’</td>
<td align="center">点标记</td>
<td align="center">‘1’</td>
<td align="center">下花三角</td>
<td align="center">‘h’</td>
<td align="center">竖六边形</td>
</tr>
<tr>
<td align="center">‘,’</td>
<td align="center">像素标记(极小点)</td>
<td align="center">‘2’</td>
<td align="center">上花三角</td>
<td align="center">‘H’</td>
<td align="center">横六边形</td>
</tr>
<tr>
<td align="center">‘o’</td>
<td align="center">实心圈标记</td>
<td align="center">‘3’</td>
<td align="center">左花三角</td>
<td align="center">‘+’</td>
<td align="center">十字</td>
</tr>
<tr>
<td align="center">‘v’</td>
<td align="center">倒三角标记</td>
<td align="center">‘4’</td>
<td align="center">右花三角</td>
<td align="center">‘x’</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">‘^’</td>
<td align="center">上三角标记</td>
<td align="center">‘s’</td>
<td align="center">实心方形</td>
<td align="center">‘D’</td>
<td align="center">菱形</td>
</tr>
<tr>
<td align="center">‘&gt;’</td>
<td align="center">右三角标记</td>
<td align="center">‘p’</td>
<td align="center">实心五角</td>
<td align="center">‘d’</td>
<td align="center">瘦菱形</td>
</tr>
<tr>
<td align="center">‘&lt;’</td>
<td align="center">左三角</td>
<td align="center">‘*’</td>
<td align="center">星形</td>
<td align="center">‘|’</td>
<td align="center">垂直线</td>
</tr>
</tbody></table>
<p><strong>另一种改变线条方式：</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">plt.plot(x, y, format_string, **kwargs)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">color</td>
<td align="center">控制颜色, color=’green’</td>
</tr>
<tr>
<td align="center">linestyle</td>
<td align="center">线条风格, linestyle=’dashed’</td>
</tr>
<tr>
<td align="center">marker</td>
<td align="center">标记风格, marker=’o’</td>
</tr>
<tr>
<td align="center">markerfacecolor</td>
<td align="center">标记颜色, markerfacecolor=’blue’</td>
</tr>
<tr>
<td align="center">markersize</td>
<td align="center">标记尺寸, markersize=20</td>
</tr>
</tbody></table>
<h3 id="复杂绘图区域"><a href="#复杂绘图区域" class="headerlink" title="复杂绘图区域"></a>复杂绘图区域</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.subplot2grid(GridSpec, CurSpec, colspan=<span class="number">1</span>, rowspan=<span class="number">1</span>)</span><br><span class="line">例子：</span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">0</span>), colspan=<span class="number">2</span>)</span><br><span class="line">第一个参数，将区域分成<span class="number">3</span>*<span class="number">3</span>类型</span><br><span class="line">选定的位置，第一行，<span class="number">0</span>列</span><br><span class="line">colspan延伸，横着向右延伸为<span class="number">2</span></span><br><span class="line">rowspan向下延伸</span><br><span class="line"></span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">0</span>,<span class="number">0</span>),colspan=<span class="number">3</span>)</span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),colspan=<span class="number">2</span>)</span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),rowspan=<span class="number">2</span>)</span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">plt.subplot2grid((<span class="number">3</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>第二种方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ax1 = plt.subplot(gs[<span class="number">0</span>,:])</span><br><span class="line">ax2 = plt.subplot(gs[<span class="number">1</span>,:<span class="number">-1</span>])</span><br><span class="line">ax3 = plt.subplot(gs[<span class="number">1</span>:,<span class="number">-1</span>])</span><br><span class="line">ax4 = plt.subplot(gs[<span class="number">2</span>,<span class="number">0</span>])</span><br><span class="line">ax5 = plt.subplot(gs[<span class="number">2</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="常见图形绘制方法"><a href="#常见图形绘制方法" class="headerlink" title="常见图形绘制方法"></a>常见图形绘制方法</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">plt.plot(x,y,fmt,…)</td>
<td align="center">绘制一个坐标图</td>
</tr>
<tr>
<td align="center">plt.boxplot(data,notch,position)</td>
<td align="center">绘制一个箱形图</td>
</tr>
<tr>
<td align="center">plt.bar(left,height,width,bottom)</td>
<td align="center">绘制一个条形图</td>
</tr>
<tr>
<td align="center">plt.barh(width,bottom,left,height)</td>
<td align="center">绘制一个横向条形图</td>
</tr>
<tr>
<td align="center">plt.polar(theta, r)</td>
<td align="center">绘制极坐标图</td>
</tr>
<tr>
<td align="center">plt.pie(data, explode)</td>
<td align="center">绘制饼图</td>
</tr>
<tr>
<td align="center">plt.psd(x,NFFT=256,pad_to,Fs)</td>
<td align="center">绘制功率谱密度图</td>
</tr>
<tr>
<td align="center">plt.specgram(x,NFFT=256,pad_to,F)</td>
<td align="center">绘制谱图</td>
</tr>
<tr>
<td align="center">plt.cohere(x,y,NFFT=256,Fs)</td>
<td align="center">绘制X‐Y的相关性函数</td>
</tr>
<tr>
<td align="center">plt.scatter(x,y)</td>
<td align="center">绘制散点图，其中，x和y长度相同</td>
</tr>
<tr>
<td align="center">plt.step(x,y,where)</td>
<td align="center">绘制步阶图</td>
</tr>
<tr>
<td align="center">plt.hist(x,bins,normed)</td>
<td align="center">绘制直方图</td>
</tr>
<tr>
<td align="center">plt.contour(X,Y,Z,N)</td>
<td align="center">绘制等值图</td>
</tr>
<tr>
<td align="center">plt.vlines()</td>
<td align="center">绘制垂直图</td>
</tr>
<tr>
<td align="center">plt.stem(x,y,linefmt,markerfmt)</td>
<td align="center">绘制柴火图</td>
</tr>
<tr>
<td align="center">plt.plot_date()</td>
<td align="center">绘制数据日期</td>
</tr>
</tbody></table>
<ul>
<li>plt.pie()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#饼图</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">labels = <span class="string">'Frog'</span>, <span class="string">'Hogs'</span>, <span class="string">'Dogs'</span>, <span class="string">'Logs'</span></span><br><span class="line">sizes = [<span class="number">15</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#尺寸，哪一快突出，标签，字体格式，阴影关闭，其实数据角度</span></span><br><span class="line">plt.pie(sizes, explode=explode, labels=labels,autopct=%<span class="number">1.1</span>f%</span><br><span class="line">       ,shadow=<span class="literal">False</span>, startangle=<span class="number">90</span>)</span><br><span class="line"><span class="comment">#xy等距离，饼图是正向看着的</span></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>plt.hist()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直方图,从所有数据中均等的选取某些数据，第二个参数确定参数的个数</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">mu, sigma=<span class="number">100</span>,<span class="number">20</span><span class="comment">#均值和标准差</span></span><br><span class="line">a = np.random.normal(mu, sigma, size=<span class="number">100</span>)</span><br><span class="line">plt.hist(a,<span class="number">10</span>,normed=<span class="number">1</span>,histtype=<span class="string">'stepfilled'</span>,facecolor=<span class="string">'b'</span>,alpha=<span class="number">0.75</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>极坐标图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">N = <span class="number">20</span></span><br><span class="line">theta = np.linspace(<span class="number">0.0</span>,<span class="number">2</span>*np.pi,N,endpoint=<span class="literal">False</span>)</span><br><span class="line">radii = <span class="number">10</span>*np.random.rand(N)</span><br><span class="line">width = np.pi/<span class="number">4</span>*np.random.rand(N)</span><br><span class="line"><span class="comment">#打开极坐标绘图选项</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>,projection=<span class="string">'polar'</span>)</span><br><span class="line">bars = ax.bar(theta,radii,width=width,bottom=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r,bar <span class="keyword">in</span> zip(radii,bars):</span><br><span class="line">  bar.set_facecolor(plt.cm.viridis(r/<span class="number">10.0</span>))</span><br><span class="line">  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>散点图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#面向对象编程</span></span><br><span class="line">fig, ax=plt.subplots()<span class="comment">#默认绘制区域为111</span></span><br><span class="line">ax.plot(<span class="number">10</span>*random.randn(<span class="number">100</span>),<span class="number">10</span>*random.randn(<span class="number">100</span>),<span class="string">'o'</span>)</span><br><span class="line">ax.set_title(<span class="string">'Simple Scatter'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>Numpy数据存取与函数</title>
    <url>/2020/03/17/Numpy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="CSV文件存取-逗号分隔值"><a href="#CSV文件存取-逗号分隔值" class="headerlink" title="CSV文件存取(逗号分隔值)"></a>CSV文件存取(逗号分隔值)</h3><ul>
<li>最简便的方法（基于numpy自定义的文件格式），适于程序中间步骤</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.save(fname, array)</td>
<td>fname：文件名，array：数组变量</td>
</tr>
<tr>
<td>np.savez(fname, array)</td>
<td>分别以.npy为扩展名，压缩扩展名为.npz</td>
</tr>
<tr>
<td>np.load(flame)</td>
<td>fname : 文件名，以.npy为扩展名，压缩扩展名为.npz</td>
</tr>
</tbody></table>
<ul>
<li><strong>存csv</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.savetxt(frame,array,fmt=<span class="string">'%.18e'</span>,delimiter=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">frame</td>
<td align="center">(文件名)文件、字符串或产生器，可以是.gz或.bz2的压缩文件</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center">存入文件的数组</td>
</tr>
<tr>
<td align="center">fmt</td>
<td align="center">写入文件的格式，例如：%d %.2f %.18e</td>
</tr>
<tr>
<td align="center">delimiter</td>
<td align="center">分割字符串，默认是任何空格</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.savetxt(<span class="string">'a.csv'</span>,a,fmt = <span class="string">'%d'</span>, delimiter = <span class="string">','</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读csv</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(frame, dtype=np.float, delimiter=<span class="literal">None</span>， unpack=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">frame</td>
<td align="center">(文件名)文件、字符串或产生器，可以是.gz或.bz2的压缩文件</td>
</tr>
<tr>
<td align="center">dtype</td>
<td align="center">数据类型，可选</td>
</tr>
<tr>
<td align="center">delimiter</td>
<td align="center">分割字符串，默认是任何空格</td>
</tr>
<tr>
<td align="center">unpack</td>
<td align="center">如果True，读入属性将分别写入不同变量</td>
</tr>
</tbody></table>
<ul>
<li><strong>写多维数据</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.tofile(frame, sep=<span class="string">''</span>, format=<span class="string">'%s'</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">frame</td>
<td align="center">(文件名)文件、字符串</td>
</tr>
<tr>
<td align="center">sep</td>
<td align="center">数据分割字符串，如果是空串，写入文件为二进制</td>
</tr>
<tr>
<td align="center">format</td>
<td align="center">写入数据的格式</td>
</tr>
</tbody></table>
<ul>
<li><strong>读多维数据</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.fromfile(frame, dtype=float, count=‐<span class="number">1</span>, sep=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">frame</td>
<td align="center">(文件名)文件、字符串</td>
</tr>
<tr>
<td align="center">dtype</td>
<td align="center">读取的数据类型</td>
</tr>
<tr>
<td align="center">count</td>
<td align="center">读入元素个数，‐1表示读入整个文件</td>
</tr>
<tr>
<td align="center">sep</td>
<td align="center">数据分割字符串，如果是空串，写入文件为二进制</td>
</tr>
</tbody></table>
<h3 id="Numpy的随机数函数-random字库"><a href="#Numpy的随机数函数-random字库" class="headerlink" title="Numpy的随机数函数-random字库"></a>Numpy的随机数函数-random字库</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rand(d0,d1,..,dn)</td>
<td align="center">根据d0‐dn创建随机数数组，浮点数，[0,1)，均匀分布</td>
</tr>
<tr>
<td align="center">randn(d0,d1,..,dn)</td>
<td align="center">根据d0‐dn创建随机数数组，标准正态分布</td>
</tr>
<tr>
<td align="center">randint(low[,high,shape])</td>
<td align="center">根据shape创建随机整数或整数数组，范围是[low, high)</td>
</tr>
<tr>
<td align="center">seed(s)</td>
<td align="center">随机数种子，s是给定的种子值</td>
</tr>
<tr>
<td align="center">shuffle(a)</td>
<td align="center">根据数组a的第0轴进行随排列，改变数组x</td>
</tr>
<tr>
<td align="center">permutation(a)</td>
<td align="center">同shuffle(a)功能，但不改变数组</td>
</tr>
<tr>
<td align="center">choice(a[,size,replace,p])</td>
<td align="center">从一维数组a中以概率p抽取元素，形成size形状新数组replace表示是否可以重用元素，默认为False</td>
</tr>
<tr>
<td align="center">uniform(low,high,size)</td>
<td align="center">产生均匀分布的数组,low起始值,high结束值,size形状</td>
</tr>
<tr>
<td align="center">normal(loc,scale,size)</td>
<td align="center">产生具有正态分布的数组,loc均值,scale标准差,size形状</td>
</tr>
<tr>
<td align="center">poisson(lam,size)</td>
<td align="center">产生具有泊松分布的数组,lam随机事件发生率,size形状</td>
</tr>
</tbody></table>
<h3 id="Numpy的统计函数"><a href="#Numpy的统计函数" class="headerlink" title="Numpy的统计函数"></a>Numpy的统计函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sum(a, axis=None)</td>
<td align="center">根据给定轴axis计算数组a相关元素之和，axis整数或元组</td>
</tr>
<tr>
<td align="center">mean(a, axis=None)</td>
<td align="center">根据给定轴axis计算数组a相关元素的期望，axis整数或元组</td>
</tr>
<tr>
<td align="center">average(a,axis=None,weights=None)</td>
<td align="center">根据轴axis计算数组a相关元素的加权平均值</td>
</tr>
<tr>
<td align="center">std(a, axis=None)</td>
<td align="center">根据给定轴axis计算数组a相关元素的标准差</td>
</tr>
<tr>
<td align="center">var(a, axis=None)</td>
<td align="center">根据给定轴axis计算数组a相关元素的方差</td>
</tr>
<tr>
<td align="center">min(a) max(a)</td>
<td align="center">计算数组a中元素的最小值、最大值</td>
</tr>
<tr>
<td align="center">argmin(a) argmax(a)</td>
<td align="center">计算数组a中元素最小值、最大值的降一维后下标</td>
</tr>
<tr>
<td align="center">unravel_index(index, shape)</td>
<td align="center">根据shape将一维下标index转换成多维下标</td>
</tr>
<tr>
<td align="center">ptp(a)</td>
<td align="center">计算数组a中元素最大值与最小值的差</td>
</tr>
<tr>
<td align="center">median(a)</td>
<td align="center">计算数组a中元素的中位数（中值）</td>
</tr>
<tr>
<td align="center">np.gradient(f)</td>
<td align="center">计算数组f中元素的梯度，当f为多维时，返回每个维度梯度</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>Numpy</title>
    <url>/2020/03/16/Numpy/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li>强大的N维数组对象：ndarray</li>
<li>线性代数，傅立叶变换的功能</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<ul>
<li>相对于python列表的<strong>优点</strong>：可以直接对数组为对象进行运算</li>
<li>用numpy生成以为数组,使得以为向量更像单个数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array([1,2,3,4,5])</span><br></pre></td></tr></table></figure>

<h3 id="N维数组对象-ndarray"><a href="#N维数组对象-ndarray" class="headerlink" title="N维数组对象-ndarray"></a>N维数组对象-ndarray</h3><p>ndarray是一个多维数组对象，由两部分构成：</p>
<pre><code>-  实际的数据
-  描述这些数据的元数据（数据维度、数据类型等）</code></pre><p>轴(axis): 保存数据的维度；秩(rank)：轴的数量</p>
<p>ndarray对象的属性</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.ndim</td>
<td align="center">秩，即轴的数量或维度的数量</td>
</tr>
<tr>
<td align="center">.shape</td>
<td align="center">ndarray对象的尺度，对于矩阵，n行m列</td>
</tr>
<tr>
<td align="center">.size</td>
<td align="center">ndarray对象元素的个数，相当于.shape中n*m的值</td>
</tr>
<tr>
<td align="center">.dtype</td>
<td align="center">ndarray对象的元素类型</td>
</tr>
<tr>
<td align="center">.itemsize</td>
<td align="center">ndarray对象中每个元素的大小，以字节为单位</td>
</tr>
</tbody></table>
<h3 id="ndarray数组的创建方法"><a href="#ndarray数组的创建方法" class="headerlink" title="ndarray数组的创建方法"></a>ndarray数组的创建方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; np.array(list&#x2F;tuple, dtype&#x3D;np.float32)</span><br></pre></td></tr></table></figure>

<p>常用函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">np.arange(n)</td>
<td align="center">类似range()函数，返回ndarray类型，元素从0到n‐1(整数类型)</td>
</tr>
<tr>
<td align="center">np.ones(shape)</td>
<td align="center">根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td align="center">np.zeros(shape)</td>
<td align="center">根据shape生成一个全0数组，shape是元组类型</td>
</tr>
<tr>
<td align="center">np.full(shape,val)</td>
<td align="center">根据shape生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td align="center">np.eye(n)</td>
<td align="center">创建一个正方的n*n单位矩阵，对角线为1，其余为0</td>
</tr>
<tr>
<td align="center">np.ones_like(a)</td>
<td align="center">根据数组a的形状生成一个全1数组</td>
</tr>
<tr>
<td align="center">np.zeros_like(a)</td>
<td align="center">根据数组a的形状生成一个全0数组</td>
</tr>
<tr>
<td align="center">np.full_like(a,val)</td>
<td align="center">根据数组a的形状生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td align="center">np.linspace()</td>
<td align="center">根据起止数据等间距地填充数据，形成数组</td>
</tr>
<tr>
<td align="center">np.concatenate()</td>
<td align="center">将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<p><strong>Note:</strong>np.linspace(1,10,4,endpoint = False)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.linspace(1,10,4,endpoint &#x3D; False)</span><br><span class="line">&gt;&gt;&gt; array([1., 3.25, 5.5, 7.75])</span><br></pre></td></tr></table></figure>

<h3 id="纬度变换"><a href="#纬度变换" class="headerlink" title="纬度变换"></a>纬度变换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.reshape(shape)</td>
<td>不改变数组元素，返回一个shape形状的数组，原数组不变</td>
</tr>
<tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但修改原数组</td>
</tr>
<tr>
<td>.swapaxes(ax1,ax2)</td>
<td>将数组n个维度中两个维度进行调换</td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维，返回折叠后的一维数组，原数组不变</td>
</tr>
<tr>
<td>.astype(np.float)</td>
<td>astype()方法一定会创建新的数组（原始数据的一个拷贝）</td>
</tr>
<tr>
<td>.tolist()</td>
<td>转换为列表</td>
</tr>
</tbody></table>
<h3 id="数组的索引和切片"><a href="#数组的索引和切片" class="headerlink" title="数组的索引和切片"></a>数组的索引和切片</h3><p>a[:, 1, 3] 不关心第一个维度，覆盖所有元素</p>
<p>a[:, :, ::2] 不关心第一个和第二个维度，第三个维度选取一半</p>
<h3 id="NumPy一元函数"><a href="#NumPy一元函数" class="headerlink" title="NumPy一元函数"></a>NumPy一元函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.abs(x) or np.fabs(x)</td>
<td>各元素的绝对值</td>
</tr>
<tr>
<td>np.sqrt(x)</td>
<td>各元素的平方根</td>
</tr>
<tr>
<td>np.square(x)</td>
<td>各元素的平方</td>
</tr>
<tr>
<td>np.log(x) np.log10(x) np.log2(x)</td>
<td>自然对数、10底对数和2底对数</td>
</tr>
<tr>
<td>np.ceil(x) np.floor(x)</td>
<td>向上舍，向下舍整数值</td>
</tr>
<tr>
<td>np.rint(x)</td>
<td>计算数组各元素的四舍五入值</td>
</tr>
<tr>
<td>np.modf(x)</td>
<td>将各元素的小数和整数部分以两个独立数组返回</td>
</tr>
<tr>
<td>np.exp(x)</td>
<td>各元素的指数值</td>
</tr>
<tr>
<td>np.cos(x)｜np.cosh(x)｜np.sin(x) ｜np.sinh(x)｜np.tan(x)｜np.tanh(x)</td>
<td>普通型和双曲型三角函数</td>
</tr>
<tr>
<td>a .mean()</td>
<td>平均值</td>
</tr>
</tbody></table>
<h3 id="NumPy二元函数"><a href="#NumPy二元函数" class="headerlink" title="NumPy二元函数"></a>NumPy二元函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+ ‐ * / **</td>
<td align="center">两个数组各元素进行对应运算</td>
</tr>
<tr>
<td align="center">np.maximum(x,y) np.fmax() np.minimum(x,y) np.fmin()</td>
<td align="center">元素级的最大值/最小值计算</td>
</tr>
<tr>
<td align="center">np.mod(x,y)</td>
<td align="center">元素级的模运算</td>
</tr>
<tr>
<td align="center">np.copysign(x,y)</td>
<td align="center">将数组y中各元素值的符号赋值给数组x对应元素</td>
</tr>
<tr>
<td align="center">&gt; &lt; &gt;= &lt;= == !=</td>
<td align="center">算术比较，产生布尔型数组</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python基础语法</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown常见语法</title>
    <url>/2020/03/15/Markdown%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>/[toc]开始时添加这个</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p># 标题：从#到######一共六级，#越多字体越小，一般我使用三级标题。</p>
<!-- more -->

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>/1. 这是第一点， 有序列表，/为转义字符</p>
<p>/- 这是第一点， 无序列表</p>
<ol>
<li>first list</li>
</ol>
<ul>
<li>second list</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>import os</code>，当行代码</p>
<p>/``` python，多行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">'Hellom Markdown'</span>)</span><br></pre></td></tr></table></figure>

<p>/```</p>
<h3 id="一些常用格式"><a href="#一些常用格式" class="headerlink" title="一些常用格式"></a>一些常用格式</h3><p><em>斜体</em>，<strong>粗体</strong>，<u>下划线</u>，<del>删除线</del>，这几种格式看快捷键</p>
<p><strong>引用</strong>： /&gt; 引用内容</p>
<blockquote>
<p>这是一段引用</p>
</blockquote>
<p><strong>链接</strong>：/[文本名]/(网站位置)</p>
<p><a href="https://www.google.com.hk/" target="_blank" rel="noopener">谷歌搜索</a></p>
<p><strong>插入图片</strong>：/![评论]/(网址)</p>
<p><img src="https://www.google.com.hk/search?q=markdown&safe=strict&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjN3t-DxZboAhWWE4gKHTVVD3UQ_AUoAnoECBYQBA#imgrc=_9bom5QATC3OYM" alt="谷歌搜索中的一张图"></p>
<p><strong>分割线</strong>：/—</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>/|吸附位点|吸附能|吸附位置|</p>
<p>/|1|2|3|</p>
<table>
<thead>
<tr>
<th>吸附位点</th>
<th>吸附能</th>
<th>吸附位置</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
<h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><ul>
<li>Mac OS数字1左边的”`”需要在英文输入法下才可以打出来</li>
<li>大部分的符号都要在英文输入法下才有效</li>
</ul>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
  <entry>
    <title>读博就像一场赌博(上海交大博士)</title>
    <url>/2020/03/15/%E8%AF%BB%E5%8D%9A%E5%B0%B1%E5%83%8F%E4%B8%80%E5%9C%BA%E8%B5%8C%E5%8D%9A(%E4%B8%8A%E6%B5%B7%E4%BA%A4%E5%A4%A7%E5%8D%9A%E5%A3%AB)/</url>
    <content><![CDATA[<h2 id="博士生学历真的很重要吗？"><a href="#博士生学历真的很重要吗？" class="headerlink" title="博士生学历真的很重要吗？"></a>博士生学历真的很重要吗？</h2><p>用讲道理的方式去说服一个人接受你的观点，通常是很难的，那我就讲讲自己的故事吧，很长，要表达的，都在里面了。</p>
<a id="more"></a>

<p>时间拉回到十六年前，2004年的第一场雪，比以往来的更早一些。我和师兄、师姐蹲在冷呵呵的实验室里，看着面前那台崭新的机器，嘎吱嘎吱向外喷涂着被融化后的ABS树脂。对于研一的我来说，一切是那么新奇和高端。我们的研究方向是导师的一个教育部课题，基于RE(reverse engineering，逆向工程)和RP(rapid prototyping，快速成型)的机械零部件快速设计制造。</p>
<p>让我万万没想到的是，十二年后，也就是2016年左右，这项技术突然火了起来，换了一个叫“3D打印”的名字，变成了可以改变世界的技术，做一份PPT能很快拿到千万级的投资。但这一切都和我无缘了，因为在2005年夏天，师兄带领师姐成功发表了4篇核心期刊论文，而我还没来得及动手，导师的项目就成功结题了。</p>
<p>然后他和其他导师合作，拿到了一个牛轰轰的863项目，两千万经费，我的“3D打印”之梦就此破灭，被迫转行。我可是给杨叔子院士写过邮件，和他探讨过RE/RP技术前景，他还鼓励我好好干呢，呜呜，拜拜了。</p>
<p>导师拍着我的肩膀，告诉我不要气馁，能力更大的人要承担更大的科研任务。我感觉他是在忽悠，但我没有证据，只是很惋惜费了我1年时间、足够发表2篇论文的实验数据。那也是我的心血呀，最后我忍痛把数据都送给学院里另一位工程硕士，保障他顺利毕业了，他非常感激我，请我在学校后门吃了一顿酸菜鱼。那个酸菜鱼馆再向北走200米，是宽阔的长江，江里的鱼都很美味，值得我们每个从这里毕业的人，毕生怀念。</p>
<p>日子还要继续，我收拾心情，转向863项目的研究工作。只是当时我还不知道，这个项目，它深刻的改变了我后来的人生。</p>
<p>在2005年，我参与的这个863项目可以说相当前沿和新潮，我负责的那部分研究内容，需要制备高性能、低表面粗糙度、纳米级的磁性薄膜(NiFe、CoFeB之类的)、搭建一套稳定的飞秒激光泵浦-探测(pump-probe)实验平台、编写数据采集软件并借助Matlab进行数据处理和运算，通过研究软磁薄膜与飞秒激光相互作用的超快瞬态动力学效应，为研发面向未来的太赫兹器件奠定坚实的理论与实验基础。</p>
<p>这对机械制造及自动化专业的我来说，简直一脸懵，就像刘姥姥进了大观园，太高端太刺激了，又因为自己啥也不懂而感到深深的自卑。在这种自卑感的驱动下，我的苦逼日子开始了，连续一年半的时间，我没有在晚上11点前回过宿舍，一直做的事情只有三件：查文献，做实验，编写Matlab。</p>
<p>有那么3个月的时间，我一直处于抑郁状态，因为辛苦做出来的实验数据，波形上总是有异常的震荡和杂波，我一遍遍的用磁控溅射方法制作薄膜、一遍遍的检查pump-probe平台、一遍遍的检查数据采集软件，最后我崩溃了，因为根本发现不出什么问题，每个环节都好像是正常的。3个多月过去了，我差不多也得上抑郁症了，和女朋友也时不时的吵架，一切都是灰暗的，看不到希望。</p>
<p>那是一个极其偶然的下午，我继续穿着净化服，在洁净室里的激光平台上重复着实验，妄图优化并查找出问题根源。洁净室有一扇封闭的玻璃窗，有个师弟坐在窗外的电脑前勤奋的工作着。我神经兮兮的盯着数据采集界面，祈祷不要悲剧重现，可是震荡和杂波还是如约而至，盘踞在实验数据界面。压抑的实验室里，我分明听到响亮的打脸声，啪啪啪啪，令人头晕目眩，眼冒金星，孤独而绝望，那一刻，我想死的心都有。</p>
<p>突然，有人在实验室外大喊师弟的名字，说他女朋友在外面等他，这个有点莽撞的家伙，猛地站起来往外跑，然后悲剧发生了，他一脚踢掉了他那个台式电脑的机箱电源，笨重的CRT显示屏一下熄灭了。师弟大喊一声卧槽，因为他那台电脑是实验室的顶配，里面每天都在不停的运行模拟程序，机箱和显示器都贴了纸条不准关闭，这一关机，跑了7~8天的模拟进程，大部分都毁掉了。我两步走到窗边敲了敲，看着师弟灰白的脸色，他勉强挤出一丝笑容，隔着玻璃大声说“导师估计要砍我了，好几个人都等着我的模拟结果呢”，我满是同情但也不知道怎么安慰他， 目送他慢慢走出去了。</p>
<p>我两步走回去，又开始观察实验结果，我发现竟然出现了奇迹，从2分钟前，也就是我走过去看师弟意外关掉电脑的那一刻，数据波形上的震荡和杂波消失了，光滑平顺接近完美，阶跃突变的信号响应也如高台跳水下落般的完美曲线，这就是我苦苦追寻了一年想要的实验结果啊，我激动的要哭了好吗？</p>
<p>看着被师弟熄灭的显示器，我恍然大悟，这种CRT的垃圾显示器，后方会产生大量的电磁辐射，一般情况下也没什么影响，但是我的pump-probe实验，需要良好的电磁屏蔽，激光锁相放大、震荡、弱信号采集都受不了CRT显示器的干扰。很快导师把CRT显示器都换成了液晶，把所有的电脑都搬离净化实验室，还给实验室的墙上加装了电磁屏蔽网，同时也给师弟的顶配电脑装了不间断备用电源，防止他再把电脑关掉。</p>
<p>后来的硕士阶段，没有了悬念，我得到了大量完美数据支撑研究结果，科研之路如开挂一般，发了好几篇论文，还在毕业前收到了SCI期刊Physica B的录用通知。尽管当时影响因子只有1不到，但是硕士就发SCI期刊论文，在只会发中文核心期刊和EI会议论文的机械学院，还是引起了很大轰动，导师也觉得挺有面子。</p>
<p>我闭着眼睛就能毕业了，心态轻松惬意，和女朋友也不吵架了。但很快我又遇到了新的困惑，我虽然用实验验证了飞秒激光和磁性薄膜相互作用的超快动力学现象的确存在，但背后存在的物理机制以及它能够应用到哪些具体的方向，我完全想不明白，我也不知道实验结果的理论基础在哪里。</p>
<p>我和导师去探讨，他觉得我想太多了，他说这是和基础学科相关的，我只是看到了表面，并没有深入进去。但当时的我，内心经历了科研过程中哥伦布发现新大陆的狂喜，我已经爱上了这种感觉，我想把这背后一切搞明白啊。我想继续纠缠着导师，他又拿到了新的课题，没空理我了，给我丢下一句话，想把理论搞明白，就去读博士吧。</p>
<p>研三的十月份，大家纷纷开始找工作了，那些研究模具、精密加工、电气控制的同学，很快都拿到好几个offer，我唯一的一次面试，是上汽到学校招聘，有个师兄是上汽的中层领导，回来面试我们。轮到面试我的时候，他拿一罐可乐，说“师弟你几分钟可以把这个造型做出来？”，我苦笑了一下，我说Pro/E和CATIA都没学啊，我研究磁性薄膜和飞秒激光去了。师兄笑着说你这个太高端了，我们不需要这么深奥的，然后我就被刷掉了。</p>
<p>这么高端的研究方向，工作肯定是不好找的，面试过这一次，我再也没去面试过了，因为我之前已经查好了，国内有个课题组研究磁性薄膜和MEMS芯片方向，我也和那边打过几次电话交流了，我想要的答案，那些潜在的电磁学机理，在那里可以找到答案。</p>
<p>硕士阶段告一段落，博士阶段的故事更精彩。</p>
<p>考试，复试，收到录取通知书，告别硕士的导师，告别硕士生涯，博士阶段就开始了。令我感到很满意的是，这里真的是可以找到答案的地方，课题组的几个牛人，有精通电磁学理论计算的，有精通薄膜制备工艺的，有精通基于薄膜制作MEMS芯片的，真是太爽了，学院里还有一条3英寸的芯片流片线，这下从理论到实验再到具体的芯片产品制造，都齐全了。</p>
<p>反正不知道别人是什么感觉，我觉得自己就像进入了阿里巴巴的宝库，我延续了硕士时期的风格，一头扎进实验室里，就不怎么想出来了，像海绵一样吸取养分，向别人不断的请教。在硕士阶段的基础上，我基于NiFe和CoFeB材料的软磁薄膜性能越做越好，我不但会用磁控溅射机，我还学会了用气相沉积设备、外延设备、硅刻蚀设备、离子束溅射与刻蚀设备、光刻机、电镀设备、烧结炉、离子注入掺杂设备、SEM(扫描电子显微镜)、XRD(x射线衍射仪)、VSM(振动样品磁强计)等一系列设备。</p>
<p>管理实验室设备的老师，都把我收为关门弟子了， 晚上如果他有事，下班时都把钥匙给我，让我关净化间的水电气，早上再老早过去开实验室。实验室的设备加起来上亿，对我也是真的信任了，这也让我比别人有了更多的时间和自由度去做实验，加速了我的科研进程。</p>
<p>而且我跟着师兄学会了手撕麦克斯韦方程组，我有个100多页的演草纸，上面全是手写的求解麦克斯韦方程的计算过程，我把麦克斯韦方程应用于求解软磁薄膜的高频磁阻变化以及随外界磁场和电场变化的响应曲线，得到的结果可以直接拟合实验结果，相似度非常高，然后就可以用理论计算得出的优化参数去指导实验工作。</p>
<p>当时有个磁阻变化率的指标，我可以和全球几个主要的相同研究方向的课题组一决高下，经常是他们做到30%，没多久我40%的结果就发论文了，然后看到他们刊出的65%的论文，我已经做到80%了，后来根据理论模型得到的参数，我不用制备薄膜的方式了，换成磁导率更高的薄带材料，指标竟然可以做到200%以上，导致国外的几个竞争对手很眼红，就赶紧跟着换材料、发论文，和我们进行比赛。</p>
<p>我超级享受这样的过程，中间还会和他们互通邮件聊一聊，就好像两个拳手打擂台赛，休息的间隙还在交流你用什么牌子的蛋白粉啊，你平时吃牛肉还是猪肉啊之类的，感觉既好玩又好笑。</p>
<p>2008年暑期，是我论文最高产的时段。我的实验工作进展顺利，手里的数据很丰富，我首先想到的是Physica B，毕竟我是老客户了，我翻出了之前发论文时给主编写过的邮件，追加了一封邮件，大意是我换了新的研究环境，有了新的研究进展，希望能把一些重要的结果在他们论文上分享给全球的同行们，然后我还说，你应该知道，现在北京正在开奥运会，希望你多关注这场盛会并享受体育带来的快乐，然后我把投稿的论文编号也发给他，希望他能关注并处理。</p>
<p>没想到，过了不到1天，主编给我回复了一封热情洋溢的邮件，感谢我对他们期刊的关心，并说自己最喜欢看跳水和体操类比赛，讲了几个我不知道的名字的运动员，最关键的是，他说收到我的投稿了，会尽快让同事处理。</p>
<p>然后，我的这篇SCI论文从投稿到修改到接受，只用了26天的时间，你说老外不讲私人感情吗？我觉得他们肯定是讲的，毕竟都是人嘛，和你聊的很好，而且你的论文做的工作又不错，加急给你发表了，也就是他们举手之劳的事情。老外也都讲感情，这个发现对我产生了很大影响，我每次投稿都要找个主编或副主编邮件聊聊天，结果2008年的暑假，我搞定了3篇SCI论文。</p>
<p>有时正在看中国队的比赛，夺冠热血沸腾的时候，一封邮件提醒弹出来，是SCI核心期刊的论文录用通知，那种美妙的、刺激的、眩晕的愉悦感觉，不做科研的人永远体会不到，也许像吸毒后的感觉。但吸毒是短暂的、要命的，而科研成就带来的愉悦是永恒的、健康的。</p>
<p>这样的日子过了1年多，有一次和导师聊天，他说一直在思索除了单纯的做器件追求性能，他更想把器件具体的应用到某个方向，开拓出一个应用领域，但这几年下来，他一直没找到合适的方向，如果找到了这样的方向，他很想发一篇Applied physics letter的论文，这是他年轻时候的一个小心愿，不过到现在还没实现。我听了心里一哆嗦，这怎么和我最近几个月在实验室里没事瞎琢磨的想法那么一致呢？</p>
<p>我也想干这个事啊，我都琢磨了很多具体方案了啊，你不问我都不知道怎么说啊，我努力帮你发个APL圆梦好了啊。再加上我平时也关注娱乐新闻，当时张国荣自杀还没几年，梅艳芳也患了宫颈癌去世了，我因为《胭脂扣》喜欢这两位明星，心里惆怅了很长一段时间。我看了一篇国外的报道，梅艳芳的去世是因为当时对宫颈癌的HPV病毒没法做到早期筛查和分型检测，HPV病毒有很多个亚型，最致命的有6种，每一种对应的治疗手段和用药都要有所区别的，所以不能做到早期筛查会出人命(因为早期的病毒在体液中的浓度含量很低很低)，筛查出来之后，无法做到精确分型，也会因为治疗手段的不太对症而延误治疗。</p>
<p>这些事情，我都考虑过很多天了，我一直在想怎么去解决这个问题，今天导师既然主动提起，我立刻满怀激动的和导师谈了2个小时，并把我的具体实验方案和如何检测讲了一遍。</p>
<p>导师听完以后一直笑，可能他也觉得我讲的不错，问我这些想法怎么来的，我说我天天都在考虑这些东西啊，其实他不知道的是，我这2月和搞生物检测的另一个同学谈过几十次了，他说针对HPV每个亚型目前已经有特定的标记物了，每种标记物只认识对应的其中一个亚型，对其他的都熟视无睹，标记物就像触手一样，会紧紧的抓住它认识的那一个亚型的病毒细胞。</p>
<p>我内心里喊了一句卧槽，思路来了：我用纳米磁性粒子修饰到病毒细胞表面、用微流体芯片分成不同检测区域、每个区域修饰不同的标记物、每个区域的标记物对应抓取不同的HPV亚型细胞、哪个或哪几个区域细胞抓的多、哪几个区域的纳米磁性粒子就多、我的传感器去检测哪几个区域的磁型号更强，不就可以检测出体液样本中包含哪种或哪几种HPV病毒了吗？而成熟的PCR扩增技术又可以解决早期病毒细胞浓度极低而检测不到的问题，从而解决早期筛查的困扰。</p>
<p>怎么做高性能传感器、怎么刻蚀微流体芯片、怎么制作纳米磁性粒子、怎么在微流体芯片检测区域表面修饰标记物、怎么在病毒细胞表面修饰纳米粒子、怎么PCR扩增、怎么处理弱磁检测信号，我和同学两个人一合作，全部都搞定了啊。兴奋，激动，我一下子又找到了硕士阶段哥伦布发现新大陆的感觉，我仔细查过文献，全球的科研圈，压根没有人用我们这种传感器做过这样的研究，这次导师主动找我聊，正好我把想法全盘托出。导师继续微笑着看我，当场批了10万块的预算，让我买各种耗材就开始整了。</p>
<p>2009年，整个一年我都很忙碌，按照之前的思路，各项试验进行的很顺利，我们一气呵成，在APL上刊出了研究成果，主编对我们还美言了一番，感谢选择他的期刊之类的话。反正也不重要了，我已经和导师举杯相庆了，我帮导师完成了课题组发表APL的心愿。导师问我接下来的想法，我说我们的高性能传感器，除了检测HPV，还能检测胃癌、肺癌、前列腺癌等各种标记物能识别的癌症细胞，能早期筛查和分型检测，我要像开挂一样的发表论文了。</p>
<p>说干就干，2010年我们又转向胃癌细胞的检测，改进了微流体芯片和传感器结构，顺利发表了两篇更高水平的论文，其中一篇在Biosensor &amp; Bioelectronics上也是快速发表，这个杂志当年影响因子6.5，那时还没现在这么多灌水的，现在影响因子都要破10了，JACS感觉到了压力。其实按照正常的发展路径，我接下来会成为一个科研能手，手握大把高质量论文，顺便申请一堆专利，承担各种国家的研究项目。但人生总是充满了变化，谁又能说的清楚呢，有两件事情的发生，对我接下来的人生方向产生了深远影响。</p>
<p>2010年，发生了两件对我很重要的事，第一件事是学校基本不再留博士毕业生任教了，这让我的导师很遗憾，原本我们计划好让我留校，然后在新领域大干一番，因为3年时间里，我已经以一作身份发了8篇SCI核心期刊，加上和别人合作的，共计14篇论文，影响因子累计40多了，而且手里正在做的实验和相关结果，已经够再发7~8篇高水平论文了，甚至冲一冲Nature materials子刊(材料应用领域的终极神刊，影响因子40)，都是有可能的。</p>
<p>用导师的话讲，我一个人可以顶别人一个课题组加起来的成果了，但现在政策变了，我没法留校了，他感觉非常遗憾。他建议我去国外读博后，然后再回来学校，有了国外的经历，就可以满足留校资格了。因为当时那几个和我是竞争对手的课题组，一直追我的进度，而且也在跟着我转向传感器进行生物检测的方向，这三个课题组的负责人都给我写邮件，法国、美国还有西班牙，邀请去做个博士后研究，然后可以考虑留下任教。面对导师的建议和国外几个课题组的邀请，我最终选择了放弃，原因是我不想继续做科研了，我要换个人生方向。</p>
<p>让我产生这种想法的原因，是源于2010年初我参加的一次在线会议，那是一个传感器国际论坛，在新加坡，我因为没有争取到经费支持，没能到现场参加。通过视频，我观看了日本那个叫Mohri的学者，做了关于磁传感器芯片的演讲，这个演讲简直给我留下了巨大的阴影，让我明白了天外有天、人外有人。</p>
<p>本来这个叫Mohri的学者，之前也一直在做和我们类似的器件研究，后来我们转向生物检测应用，他们就没有声音了。我因为做了一点生物检测的工作，发了几篇论文，就开始琢磨这个东西应该可以产业化的，但我们搭建的实验平台粗大笨重，信号处理都是PCB板级的电路，高频信号激励是买了一台笨重的阻抗分析仪还有一台信号发生器，整个实验系统满满当当占了半个实验室。但是，这个Mohri教授，沉寂的几年，他竟然找到日本爱知钢铁投资了他，把传感器的敏感单元、信号处理、阻抗匹配、高频信号激励、电磁屏蔽等模块，全部集成化做进了一个2mm*2mm的封装芯片里面，然后给日本的手机厂商供货，开始做手机里面的电子罗盘和地磁方位检测了。</p>
<p>这个讲座让我整个人是崩溃的，2mm*2mm的面积是我的传感器敏感单元的尺寸，而其他的环节，我用了半间实验室的面积，人家却都集成都芯片里面了，而且已经过了研发的阶段，而且已经给手机厂商供货了，而且都申请了很多专利了。虽然单片的性能比我的差一大截，但在手机领域的应用，人家Mohri的产品是够用的，我只能用一大堆笨重的仪器，去做各种生物检测然后刷论文，离实际变成集成化的产品，还差了十万光年距离。</p>
<p>我开始怀疑我的研究方向的意义，我从事应用科学研究，就是应该像Mohri一样，把成果变成实实在在的产品，去推动某一个产业的进步，但看着我那一大堆笨重的仪器，又有种深深的无力感，就算再牛，我一个人也搞定不了这件事，这是个系统工程啊。爱知钢铁给Mohri配置了50人的研发团队，涵盖电子、半导体、传感器、芯片封装各个领域的工程师，而我有什么，我就是一个孤单的螳螂，高高举起手臂，却推动不了事业的车轮。</p>
<p>但机会总是留给有准备的人，我08年无意间做的一件事情，在2010年我面临人生抉择时，开始发挥作用了。我之前讲过了，和管实验室的老师关系处的很好，实验室的设备我基本都会使用，机缘巧合下，我认识了一个已经毕业的师兄，他回来学校想做一些实验，关于陶瓷材料掺杂和烧结的东西，那两个破设备几乎都没人用，像垃圾一样丢在那里。</p>
<p>听说我会使用，已经毕业的师兄找到我，给了我一些样品，让我帮他做实验，我有实验室的钥匙，晚上10点后，其他人都走了，我一个人留下来，一边制作我的薄膜传感器，一边帮师兄做样品。2008年9~12月，4个月的时间，我做了6个批次的样品，师兄很感激我，请我吃了一顿酸菜鱼(还记得工程硕士的同学也请我吃的酸菜鱼吗？)，然后给我讲了一个非常精彩的故事，他希望我可以沿着这个方向做下去。我看到命运之神向我招手，他手指一个充满挑战的方向，让我冲上去，挑战未知的困难。</p>
<p>师兄给我的样品是一种陶瓷芯片，是非常好的产品方向，07年国家要对机动车实施排放管制，所有汽车都要出厂强制安装，但是当时，全球只有德国、美国、日本三家公司有相关技术储备，中国这一块市场注定被别人垄断。</p>
<p>师兄给的样品正是这个方向，他委托我做的样品，经过几家机构的检测，性能相当不错，接下来，要找到一个合适的代工厂伙伴，把这种陶瓷芯片批量化生产，然后在经过集成化的产品封装设计，把信号传输、热保护、抗振动、机械固定等装置与芯片集成起来，做成终端产品，与发动机匹配使用。国外几家公司的技术严密封锁，核心的芯片工艺没有人能够接触得到，也不会对外销售，只能靠自己做出来。我和师兄只做出了初版的芯片产品，还需要优化才能量产，而且后续还牵涉到封装设计和匹配使用，我们对这些一无所知。</p>
<p>想了解全套的东西，只有到一家国外一线的汽车公司的发动机部门去工作，还要正好负责这一块产品的开发，那就可以以客户的身份，了解这些东西。但是说起来容易，哪里有那么正好的机会，一个大牌的汽车公司，正好发动机部门有这个新产品开发的职位空缺？</p>
<p>机缘巧合，天赐良机，2010年12月，某一线国际品牌汽车公司，发动机研发部招聘，有个职位专门负责这个新产品的开发，和师兄商量之后，我毫不犹豫的投了简历，干脆利落的被录用了，工资对于刚毕业的博士来说也算不错。不能让我留校，导师为了补偿我，就让我提前毕业了，还帮我争取到了校级优秀毕业生和校级优秀毕业论文，我很感谢他，从他身上学到了很多科学方法和科研精神，让我终生感激。</p>
<p>临走时，导师单独和我长谈了一次，他说的一番话，我觉得很好的诠释了博士学位的意义：得到博士学位不是终点，不代表你以后能比别人成功，但博士学位能代表的是，只要你愿意，你可以做好这个世界上几乎所有的、有技术含量的事情。就这样，我告别了博士导师，告别了科研之路，踏上一场未知之旅，但我没有任何犹豫，我要追寻的东西，已经不在校园里了。</p>
<p>不知不觉已经8000字了，博士阶段告一段落，但博士毕业后的经历会更刺激。看一个凡人如何在人生路上步步修炼，所有内容都是真人真事，和大家一起分享。</p>
<p>2011年开始工作了，工作的前2年，我和刚进入博士阶段一样，每天都在接触和吸收新的东西，由于核心芯片已经做出来了，我很快能理解总成产品的各种技术细节，而且我每天在琢磨的是，如果让我来研发和生产这个产品，我应该如何改进，可以做的更好。</p>
<p>工作2年之后，每次到供应商那里，他们都有点怕我了，因为我提出的问题他们已经开始回答不了，他们不敢在我面前有任何的隐瞒和虚假数据，我对产品了解的深度已经超过了他们。到第3年结束，我觉得差不多了，这个职位已经没有更多可以让我学习的东西了，我和师兄商量了一下，计划第4年离开汽车公司，开启属于自己的事业。</p>
<p>但在离开之前，还有两件事必须完成：1 和代工厂一起努力，把我们核心的芯片产品批量生产的一致性和稳定性的问题解决，成品率提升到90%以上；2 我必须自己组建创业团队，然后去找投资机构，拿到天使轮融资。</p>
<p>第1件是技术上的事，总归是能解决的，我们加班加点、多多搬砖，逐渐能达到量产的标准了，但是第2件事，我又开始懵了，刘姥姥又一次进大观园，完全不知道怎么去做，只有查资料慢慢学着准备。</p>
<p>我印象深刻的是有一本电子书，叫《给你一个亿，你能干什么》，里面有一个章节叫商业计划书 (BP) 的21条军规，特别感谢作者查立先生，我按着他讲的内容，一步步操作，最终做出了一份当时自认为很满意、但现在看起来比较垃圾的第一版BP。然后我准备各种资料，学着展示产品和性能测试报告，组建技术/质量/采购/生产管理的团队，向别人描绘市场前景，做财务分析，做盈利预测，做现金流量预算，做SWOT，用了1年的时间，在朋友的介绍下，有两个天使投资人的资金到位了，感谢金主爸爸，可以放开手脚干了。</p>
<p>2015年我从公司正式离职，最后的一年感觉挺对不起主管，我经常迟到早退，去筹备自己的事情，但主管还是宽容的忍受了我一年，大概也是因为其他人没法专业而深刻的管理这么多传感器产品吧。临别时，请主管和同事们一起吃了一顿酸菜鱼 (第三顿了)，主管祝我前程似锦，我祝他以后别再有我这么不听话的下属。然后他好像受到了我的启发，在我走后的3个月，也麻溜的离职，跳槽到杭州湾南岸去了，据说工资翻了一倍还多。</p>
<p>2015年，我和师兄的芯片已经可以稳定量产了，我基于前面4年的工作经验并融入很多改进优化，在2016年终于有了完全自己制造出来的总成产品，并趁热打铁申请了一系列专利。2016年又发生了两件影响重大的事情，可能是我在做天使轮融资的时候，讲了太多次BP，导致我的演讲技能大幅提升，讲起项目口才就好的不行。</p>
<p>我参加了一个领军人才项目评比，滔滔不绝的向很多专家评委进行介绍，由于产品有独创性，芯片是自主产权，而且市场前景巨大，公司成立一年就开始有销售收入了，项目答辩取得很好的名次，拿了300万政府资助，对创业初期起到了很好的资金补充。当地政府看我这么能讲，产品又好，就怂恿我去参加省里的创新创业大赛，我去了又是一顿讲，拿到了第二名，领导很开心，然后省里市里都给公司奖励，省市的领导接见我，还不停到公司走访，给了很多支持。</p>
<p>他们的态度都很诚恳，能看得出对核心技术、对踏踏实实的创业者那种发自内心的尊重和鼓励，以至于我和他们都成了很好的朋友。我们的目标是一致的，都是希望尽快把产业做大，打破垄断格局，我可以收获成功，他们能得到一家成功的企业，带动就业、带动税收、带动人才的聚集。这种良性互动的局面在中国沿海省份已成普遍现象，让更多的技术型企业成长起来，是中国产业结构转型成功必须要做的事。</p>
<p>2016年的第二件大事来了，我记得那天是科技局的一位局长和我约了时间，他说每年科技部都会举办一次全国创新创业大赛，我在省里取得了好名次，他们决定推荐我参加全国创新创业大赛。局长一脸严肃的和我说，已经四年了，他推荐的本地企业，没有一家通过预赛并进入半决赛的。</p>
<p>我问大概多少家进行比赛，局长说各省推荐能进入国家赛的，基本是按照每个大的行业1000名，到国家赛的预赛里从1000家企业选出100家进入半决赛，然后半决赛从100家选出10家进入决赛，两轮10进1之后，基本剩下的10家都是非常厉害的企业了，大家再争冠亚军和第三名。我说领导啊，你是不是觉得我比较能吹，才推荐我去参加的，这么残酷的淘汰赛，我也没底啊。领导笑了，说你这样的博士真不多见，技术专家，口才又滔滔不绝，也不紧张，我看好你啊。</p>
<p>说不紧张是假的，当我一个人背着包，坐上去参加大赛的高铁时，心里是惊恐不安的。1000名来自全国各地的人才们，把我丢进去都找不到在哪里，完全不起眼。但我在准备PPT的时候，一直回响着博士导师说的话，一篇论文、一份报告、一个项目，最核心的灵魂在于你把创新性讲清楚，最好的创新性不是你比别人做的好，而是你做了别人根本没做过的事情，开创了一个领域。</p>
<p>我的产品，放到世界范围肯定不是原创的东西，因为有3家国外巨头公司已经做出来了，但是放到中国范围内，除了我根本没有人做过啊，我决定从这个角度开始讲。比赛时是10个企业分为一组，PPT讲完第一遍，我以小组第一从1000个企业里杀出来，进入到半决赛；PPT讲完第二遍，我再次以小组第一从100个企业里杀出来，进入到总决赛，这时，只剩下10家企业了。</p>
<p>出人意料的，是总决赛的前一天晚上，在酒店的会议室里，大赛的带队老师，把我们10家企业都召集在一起，说了一些恭喜的话，让我们加油之类的。然后又很严肃的说，你们10位入选者，都是博士学位，国家想在未来的10年内，从本土选拔近万名专家人才，入选“万 人计划专家”，这也是没办法的事，国家要转型升级，要科技强国，没有专家人才，都是空谈，而这一万多名“万 人计划专家”，就是科技强国的领军者，国家迫切需要你们。</p>
<p>这次请你们来开会，就是想告诉大家，你们都是博士，如果明天能进入前三名，科技部有一个大赛通道，把你们推荐到中组部，再经过一轮答辩和评选，就可以入选“万 人计划专家”，希望你们把握这个弥足珍贵的机会。老师的一番话讲完，我看了看其余9个家伙，好像眼睛都发红了，身上已经散发出隐隐的杀气，看起来明天要拼命了。不由得心中一寒，也赶紧假装很有杀气的样子，不能在气势上先输给他们。</p>
<p>回想起大家的杀气，我吓得夜里一直睡不着，我总觉得按照之前预赛和半决赛的套路，只讲创新性是不行的，要有一些更打动人的东西。我翻出来几只芯片样品，小小的，拿在手里，那样的不起眼，但又充满了科技感和铜臭味，我盯着它们看了一个小时，我决定，我不再只是强调创新性了，我要讲一个关于芯片的煽情故事。12个小时后，我排在第6顺位出场，听完主持人的转场介绍，我从位置上站起来，伴着场下的掌声上台了，PPT投放在巨大的屏幕上，镁光灯在眼前聚焦，我看不到台下的任何人，我仿佛回到了学校夜晚12点的实验室里，静悄悄的只有我一个人不停的奋斗着。</p>
<p>我从口袋里掏出芯片，举在手上，今天，我要给大家讲一个芯片的故事，这个记载了我8年青春回忆的小物件，就这样被我举着，竟然感觉沉甸甸的，我想起了这些年的辛劳、奋斗、挫折、彷徨、希望、喜悦、兴奋、刺激，就在这个时刻，浓缩为8分钟的演讲，与大家分享吧。我已经不记得当时的细节了，只记得自己讲完后，鞠躬致谢，恍惚中看到台下有很多人站了起来，连绵不断的在鼓掌，持续了半分钟还没有停下来。时间定格在10位参赛者都结束了演讲，计分屏上我的名字排在第二位，我揉了揉眼睛，没错，我是总决赛第二名了。</p>
<p>科技部信守了他们的承诺，2年半之后，通过新一轮的答辩和选拔，我入选了中组部国家万 人 计划专家，我会和另外一万多名专家一起，成为国家科技强国、升级转型的领军者，在这个古老的国家伟大复兴的道路上，与国外的竞争对手展开厮杀，最终杀出一条血路，加冕为王。</p>
<p>我和师兄创办的公司，从16年开始到现在，每年的销售额都以2~3倍的速度增长，后续还会增长的更快，公司的估值今年也到了5亿(是估值，不是个人资产)。但我们依然买不起大别墅，不舍得换保时捷，依然加班到夜里12点以后，依然把公司利润的大部分都投入到研发中去，依然出差的时候不舍得住超过400元的酒店，依然像守财奴一样守着投资人新投入的几千万现金不敢乱花。</p>
<p>但我们从学院里那个阿里巴巴宝库学到的东西，还有我们可以手撕麦克斯韦方程组的功底，可以让我们再开发出几款市场容量过千亿的科技产品，可以再组建几个团队，再创办几家估值超过5亿的公司，再开拓几个无人涉及的研究领域。</p>
<p>在美丽的丽江古镇，有一座雪山，终年云雾缭绕，即使在最晴朗的日子，阳光也无法穿透云层。传说只有本领非凡、与山齐高者，才能看到云朵以上的风景。世间虽少有非凡之人，但看过者，无不终生称道绝世美景。</p>
<ul>
<li>不工作的时候，我喜欢叫朋友们一起打王者，一起吃鸡；</li>
<li>我喜欢没事就去逗逗狗，撸撸猫，和小朋友一起到处玩；</li>
<li>我喜欢所有Alan Walker的歌，不开心的时候就一直听；</li>
<li>我和朋友到迪厅蹦迪，吃火锅撸串喝酒，K歌到深夜；</li>
<li>情人节还有结婚纪念日，我给老婆买花买钻戒买LV包；</li>
<li>我到菜场买菜经常被坑，去小区扔垃圾没分好类会被骂；</li>
</ul>
<p>身边的人，几乎很少知道我上面讲的那些硕士、博士还有创业的事情，我平时展示的，只是我想展示的，那云朵以下、接连地气、炊烟袅袅的风景。而云朵以上的风景，只有与山齐高者才能看到，你没看见，不代表没有。就像你不会手撕麦克斯韦方程组，没看过杨-米尔斯理论的推导过程，你就不知道杨振宁的伟大紧随麦克斯韦之后，薛定谔和霍金与他相比，都是弟弟。你所看到的，只是他82岁那年，与28岁年轻妻子的传闻。</p>
<p>疫情还没爆发的1月初，我去了一位朋友的公司，他是很早就归国的行业专家，在贝尔实验室和西门子待了十几年，办了一家纳斯达克上市的公司，然后回国创业。到公司的时候，他开发的机器人正在惟妙惟肖的讲课，对着摄像头给孩子们网络直播，脸上的表情还可以各种变换，憨态可掬。坐在他的办公室喝茶，桌子上也有个机器人，这位朋友和我聊他在美国的经历，聊自己的最新产品。</p>
<p>然后他扶着桌上的机器人，打开一个开关说：“我经常喜欢把机器人比作我们的国家，你看头部的这个处理器代表政治中心，胸部的电池包代表驱动发展的工业动力，双腿是支撑国家的农业基础，手臂代表执法机构，嘴巴代表外交和宣传部门，体内的各种电线电缆代表交通网络，漂亮的衣服、面容和发型代表娱乐业和服务业。”</p>
<p>然后他顿了一下，打开机器人的后背开关，里面露出两个像液压挺杆的支撑柱，牢牢支撑着机器人沉重的金属躯体，他指着两根支撑柱说，“搞技术和研发的都在这里了，有了我们，国家可以顶天立地的站着，不用卑躬屈膝，也不需要下跪乞求，我们是脊梁。”</p>
<p>如果让我选出人生中最幸福的两件事，那么第一件，是在大学的图书馆里遇见我孩子的妈妈，而第二件，就是选择读博。</p>
]]></content>
      <categories>
        <category>杂学杂记</category>
      </categories>
  </entry>
</search>
